<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 398]]></title>
    <url>%2F2018%2F04%2F03%2FLeetCode-Challenge-log-398%2F</url>
    <content type="text"><![CDATA[398. Random Pick Indexhttps://leetcode.com/problems/random-pick-index/description/ Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note:The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: 12345678int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); Solution: space O(1), time O(n) use 1 slot to hold output. if the n^th index is found, it has 1/n probability to replace the slot. (can use mutiple slot and the answer will be same) 123456789101112131415161718192021222324252627282930import random as rdclass Solution: nums = [] def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def pick(self, target): """ :type target: int :rtype: int """ output = None count = 0 for i in range(len(self.nums)): if self.nums[i] == target: count += 1 if output is None or rd.randint(1,count) == 1: output = i if output is None: return None return output# Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.pick(target) 1234567891011121314151617181920212223242526272829303132333435# first try, use two slotsimport random as rdclass Solution: nums = [] def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def pick(self, target): """ :type target: int :rtype: int """ can = [] count = 0 for i in range(len(self.nums)): if self.nums[i] == target: count += 1 if len(can) &lt; 2: can.append(i) else: temp = rd.randint(1,count) if temp &lt;= 2: can[temp-1] = i if len(can) == 0: return None if len(can) == 1: return can[0] return can[rd.randint(0,1)]# Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.pick(target)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 191]]></title>
    <url>%2F2018%2F04%2F03%2FLeetCode-Challenge-log-191%2F</url>
    <content type="text"><![CDATA[191. Number of 1 Bitshttps://leetcode.com/problems/number-of-1-bits/description/ Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. Solution:12345678910111213# normal solution O(log n) = O(32) = O(1), since n = 32 bitsclass Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 count = 1 while (n&gt;1): if n % 2 == 1: count += 1 n = n // 2 return count 123456789101112# bit operation trick O(1)class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n != 0: n = n &amp; n-1 count += 1 return count 12345678# built-in function (cheating)class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ return bin(n).count('1') Python bit operation:123456789101112131415161718192021a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0c = a &amp; b; # 12 = 0000 1100print "Line 1 - Value of c is ", cc = a | b; # 61 = 0011 1101 print "Line 2 - Value of c is ", cc = a ^ b; # 49 = 0011 0001print "Line 3 - Value of c is ", cc = ~a; # -61 = 1100 0011print "Line 4 - Value of c is ", cc = a &lt;&lt; 2; # 240 = 1111 0000print "Line 5 - Value of c is ", cc = a &gt;&gt; 2; # 15 = 0000 1111print "Line 6 - Value of c is ", c]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 9: Polymophism]]></title>
    <url>%2F2018%2F03%2F29%2FJava-Review-9%2F</url>
    <content type="text"></content>
      <tags>
        <tag>-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 101]]></title>
    <url>%2F2018%2F03%2F29%2FLeetCode-Challenge-log-101%2F</url>
    <content type="text"><![CDATA[101. Symmetric Treehttps://leetcode.com/problems/symmetric-tree/description/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. Solution: iterative 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if root is None: return True q1 = [root] q2 = [root] pointer = 0 while (pointer &lt; len(q1)): l = q1[pointer] r = q2[pointer] # both none if (l is None and r is None): pointer += 1 continue # one none if (l is None or r is None): return False # equal if (l.val == r.val): q1 = q1 + [l.left, l.right] q2 = q2 + [r.right, r.left] pointer += 1 continue # not equal if (l.val != r.val): return False return True ​ recursive 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if root is None: return True return isMirror(root.left, root.right) def isMirror(l,r): if (l is None) and (r is None): return True if (l is None) or (r is None): return False if (l.val == r.val) and (isMirror(l.left, r.right)) and (isMirror(l.right, r.left)): return True return False ​]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 807]]></title>
    <url>%2F2018%2F03%2F29%2FLeetCode-Challenge-log-807%2F</url>
    <content type="text"><![CDATA[807. Max Increase to Keep City Skylinehttps://leetcode.com/problems/max-increase-to-keep-city-skyline/description/ In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? 12345678910111213141516171819Example:Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]Output: 35Explanation: The grid is:[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ]The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3]The grid after increasing the height of buildings without affecting skylines is:gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes: 1 &lt; grid.length = grid[0].length &lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism. Solution:123456789101112131415161718192021class Solution: def maxIncreaseKeepingSkyline(self, grid): """ :type grid: List[List[int]] :rtype: int """ n = len(grid) mrow = [0]*n mcol = [0]*n for i in range(n): for j in range(n): mrow[i] = max(mrow[i], grid[i][j]) mcol[j] = max(mcol[j], grid[i][j]) maxHeight = 0 for i in range(n): for j in range(n): tmp = min(mrow[i], mcol[j])-grid[i][j] maxHeight += tmp return maxHeight]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 8: Object class]]></title>
    <url>%2F2018%2F03%2F28%2FJava-Review-8%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Java API specfication: http://www.oracle.com/technetwork/java/api-141528.html I. Object Object is the root class of all classes. ex. 1public class &lt;classnanme&gt;&#123;&#125; is equal to 1public class &lt;classnanme&gt; extends Object&#123;&#125; toString(): when connector is used, this super method is auto-executed. return “\&lt;classname>@\&lt;hashcode>“. usually overriden. equals(): if using ==, it is actually comparing ref. address. default is same as == should be overriden, ex: 123456789101112public boolean equals(Object obj)&#123; if (obj == null) return false; else&#123; if (obj instanceof Cat)&#123; Cat c = (Cat) obj; if (c.color ==this color &amp;&amp; c.height == this.height)&#123; return true; &#125; &#125; &#125; return false;&#125; II. Casting A superclass ref. can point to its subclass instance. For above, it can not access new member variables in its subclass. instanceof can be used to check if an instance belongs to a class or superclass. upcasting: treat subclass as superclass; downcasting: treat superclass as subclass; 1234567891011121314151617181920212223//sample application public class Test&#123; public static void main(String args[])&#123; Test test = new Test(); Animal a = new Animal("name"); Cat c = new Cat("catname", "blue"); Dog d = new Dog("dogname", "black"); test.f(a); test.f(c); test.f(d); &#125; public void f(Animal a)&#123; System.out.println("name: " + a.name); if (a instanceof Cat)&#123; Cat cat = (Cat)a; System.out.println("eyecolor: " + cat.eyecolor); &#125; else if (a instanceof Dog) &#123; Dog dog = (Dog)a; System.out.println("furcolor: " + dog.furcolor); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 1]]></title>
    <url>%2F2018%2F03%2F28%2FLeetCode-Challenge-log-1%2F</url>
    <content type="text"><![CDATA[1. Two Sumhttps://leetcode.com/problems/two-sum/description/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 12345678910111213141516# Keywords: hash table, dictionaryclass Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ n = len(nums) ht = &#123;&#125; for i in range(n): temp = target - nums[i] if ht.__contains__(temp) and ht[temp] != i: return [ht[temp], i] ht[nums[i]] = i return None]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 7: Access control]]></title>
    <url>%2F2018%2F03%2F27%2FJava-Review-7%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 I. Access control keywords keyword within class within package son class anywhere private ✅ default ✅ ✅ protected ✅ ✅ ✅ public ✅ ✅ ✅ ✅ For class, only public and default are used. default members can be accessed by a class that belongs to the same package. II. Use extends to inherit A son class inherits all members of its superclass (varibales and methods). Java only allows single inheritage. A son can have only one father(superclass). 1&lt;modifier&gt; class &lt;name&gt; [extends &lt;superclass&gt;]&#123;...&#125; III. Overwite (override) A method of a son class can override the original method in its superclass. To realize, the followings needs to be satisfied: same name. same return type. same parameters list. can not use stricter access control. ​ IV. Super In a son class, use super.&lt;name&gt; to refer superclass members. V. Constructive method in inheritage Son constructive method must first use superclass constructive method. If no super used, the son’s constructive method first executes the superclass’s non-parametrized constructive method, namely super(); If there exists no super(), compile error. The alternate is to use super(p1,p2) in the first line to call specific superclass’s constructive method.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 6: Package & import]]></title>
    <url>%2F2018%2F03%2F22%2FJava-Review-6%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 package &amp; import are used to resolve repeated class names. package Declare what package the class(es) belongs to. Declared at 1st line in java: 1package pk1.pk2.pk3; If none package line —&gt; nameless package . Java manages packages by directory. For instance, the above .java will located at ./pk1/pk2/pk3. import12345678//specific classimport pk1.pk2.pk3.classname;// all classes of a packageimport pk1.pk2.pk3.*; //without importpk1.pk2.pk3.classname abc = new pk1.pk2.pk3.classname() JDK main packages java.lang: String, Math, Integer, System, Thread (default import) java.awt: abstract window toolkits java.applet java.net jave.io java.util 1jar -cvf xx.jar *.*]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gundam] MG ZZ (processing)]]></title>
    <url>%2F2018%2F03%2F21%2FGundam-MG-ZZ-processing%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Gundam</tag>
        <tag>MG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 5: this and static]]></title>
    <url>%2F2018%2F03%2F16%2FJava-Review-5%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Keyword this In a method of a class , this refers to the object that uses the method. Sometime it can be used to deal with the case that member varibales and method parameters have same names. (ref. uses the closest def.) this can be view as a variable, whose value is the reference of the current object. Keyword static In a class, a static member variable is defined to be a shared variable for the class. When the class is first used, thestatic variable is initialized. For all the instance of the class, there is only one copy of this varible. When a method is defined as static, this method, as it is called, will not parsed the ref. of the instance to the method, and hence will not able to use non-static variables. We can use either instance ref. or class name (without a instance) to access static members. 12345678910111213141516171819202122// ex: use static var as counterpublic class Cat&#123; private static int sid = 0; private String name; int id; Cat(String name)&#123; this.name = name; id = sid++; &#125; public void info()&#123; System.out.println ("My name is" + name + "No." + id); &#125; public static void main(String arg[])&#123; Cat.sid = 100; Cat mimi = new Cat("mimi"); Cat pipi = new Cat("pipi"); mimi.info(); pipi.info(); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 4: Ram analysis]]></title>
    <url>%2F2018%2F03%2F16%2FJava-Review-4%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Step by step ram analysis Corresponding Code: 1234567891011121314151617181920212223242526272829303132333435363738public class Point &#123; double x; double y; double z; Point(double _x, double _y, double _z)&#123; x = _x; y = _y; z = _z; &#125; public void setX(double _x)&#123; x = _x; &#125; public void setY(double _y)&#123; y = _y; &#125; public void setZ(double _z)&#123; z = _z; &#125; public double getDistance(Point p)&#123; return Math.pow(x-p.x,2) + Math.pow(y-p.y,2) + Math.pow(y-p.y,2); &#125;&#125;class TestPoint&#123; public static void main(String[] args) &#123; double a = 1.0, b = 2.0, c = 3.0; Point p1 = new Point(a, b, c); p1.setX(4); System.out.println(p1.getDistance(new Point(3,2,1))); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Parameters Parsing]]></title>
    <url>%2F2018%2F03%2F16%2FNotes-Parameters-Parsing%2F</url>
    <content type="text"><![CDATA[Diffrent languages has diffrent features about parsing parameters. There exists a lot of cofusion around this topic, especailly as people tends to use words like “parsing reference” and “parsing values” trying simplify the problem. Unfortunately, it only leads to more confusion. We need to understand the lower layer. Java All are parsed by values. Eight primitive data types (char, byte, short, int, long, float, double, boolean) are saved in stack. When called, the value of the data is parsed. Refrence data types (object, array) are saved in heap, referred by a address saved in stack. When called, the address value is parsed. Special notice: a String, although being a object, can be viewed as same as ptimitive data type. Because the content in a String is immutable. Python Mutable data type: list, dict and others are parsed by reference. Immutable data type: number, string and tuple type are parsed by value. … to be continued]]></content>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 3: Object oriented programming]]></title>
    <url>%2F2018%2F03%2F15%2FJava-Review-3%2F</url>
    <content type="text"><![CDATA[The following notes are based on the book: &lt;&lt; Head First JAVA &gt;&gt; and video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Process - oriented programming divde into processes process by process Object - oriented programming divide into objects(tools) realized by methods within a object everthing in java is a object Resuseable, Extensibility, easy to maintain and replace Object and class A object is an instance of a class. A class is a template. A object has attribute (member variable) and method. Relationships between classes (more later) Inheritance Association Composition Aggregation Realization Define a class Member variables can have a default. otherwise java automatically init them (0, ‘0’, null). 123456789public class Person()&#123; // member varibles int id; int age = 20; public void sayHello()&#123; System.out.print('hello!'); &#125;&#125; Construction method same name as class no return, no void 123456789public class Person&#123; int id; int age = 20; Person(int _id, int _age)&#123; id = _id; age = _age; &#125;&#125; Default construction method if no construction method is specified, default is used: 1Person()&#123;&#125; otherwise, default is overridden. Overload construction method Mutiple construction methods are allowed. Method names have to be same (same as class name). Can be distinguished by either: number of parameters paremeters’ types 12345678// init person with specific id and agePerson(int _id, int _age)&#123; id = _id; age = _age;&#125;// init person with specific id and default age (set to 20 mannually)Person(int _id)&#123; id = _id; age = 20;&#125;// init person with default age and default idPerson()&#123;id = _id; age = _age;&#125; Overload normal method same as above Method return type also need to be same. Reference type takes two space in ram. (address and instance) address is saved in stack ram. new instance is saved in heap ram. method does not use space until called! 12String s; // create a reference type, iss = new String('hello world'); // create a instance, assigned to s Rule of naming Class names begin with upper case. Variable names and method names begin with lower case. Use camelSignal if a name contains mutiple words.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 2: Java syntax and more]]></title>
    <url>%2F2018%2F03%2F15%2FJava-Review-2%2F</url>
    <content type="text"><![CDATA[The following notes are based on the book: &lt;&lt; Head First JAVA &gt;&gt; and video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 - For loopThe process follows: execute ep1 if ep2 is true, go to 3; otherwise break; execute statements execute ep3 iterate again 2~4 1234for (ep1; ep2; ep3)&#123; statement1; statement2; &#125; - While loop1234while(ep)&#123; statement1; statement2;&#125; - Do while loop12345//noteic the ';' after while!!!do &#123; st1; st2;&#125; while (ep); - If else12345if (ep1)&#123;&#125;if (ep1)&#123;&#125; else&#123;&#125;if (ep1)&#123;&#125; else if (ep2)&#123;&#125; else&#123;&#125; - Switch i must be int (char, short). if i = 8 , st1 is executed. case can dig through if breaknot existed. ex. if i = 10, st3 and st4 are executed. default is used to handle no-match. 123456789101112131415//exampleint i = 8;switch (i) &#123; case 8: st1; break; case 10: case 11: st3; case 12: st4; break; default: st5;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Unicode]]></title>
    <url>%2F2018%2F03%2F14%2FNotes-Unicode%2F</url>
    <content type="text"><![CDATA[Excerpt from https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html: 所以我们也可以这样理解,Unicode是用0至65535之间的数字来表示所有字符.其中0至127这128个数字表示的字符仍然跟ASCII完全一样.65536是2的16次方.这是第一步.第二步就是怎么把0至65535这些数字转化成01串保存到计算机中.这肯定就有不同的保存方式了.于是出现了UTF(unicode transformation format),有UTF-8,UTF-16. There are many problems can be caused by encoding. So it is a must to know how different languages handles encoding issues: Javajava uses unicode = utf-16 internally, but it seems neccessary to set it up on the surface. 1234567891011121314// set and print encodeing typeSystem.setProperty("file.encoding", "UTF-16");String a = System.getProperty("file.encoding");//conversion try &#123; // Convert from Unicode to UTF-8 String string = "abc\u5639\u563b"; byte[] utf8 = string.getBytes("UTF-8"); // Convert from UTF-8 to Unicode string = new String(utf8, "UTF-8");&#125; catch (UnsupportedEncodingException e) &#123;&#125; Python In Python 3, all strings are sequences of Unicode characters. There is a bytes type that holds raw bytes. In Python 2, a string may be of type str or of type unicode. You can tell which using code something like this: isinstance(s,str/unicode) 1234567891011# check encodeing type import syssys.getdefaultencoding()# set encoding type ("utf-8", "utf-16")#coding=utf-8# conversion ("utf-8", "utf-16", "unicode-escape" )s = '你好'ec = s.encode("utf-8")dc = ec.decode("utf-8")]]></content>
      <tags>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 1: The World of Java]]></title>
    <url>%2F2018%2F03%2F12%2FJava-Review-1%2F</url>
    <content type="text"><![CDATA[The following notes are based on the book: &lt;&lt; Head First JAVA &gt;&gt; and video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 - Java is a interpreted languageAfter .java is compiled into .class, JVM takes .class as input, one line at a time, translates a line into machine language to have it executed. (The other kind is complied language, ex. C/C++) - Garbage CollectionJava has its own garbage collector to automatically clean up the unused ram. (C/C++ needs coder to manunlly specify the clean-up process) - Java’s work flow: JVM - Ram segement heap: new. stack: local data. data segment: static data, const data. code segment: code. - TerminologyJDK: java development kit (developer) JRE: java runtime environment (user) - Run java in shell12$ javac HelloWorld.class //compile$ java HelloWolrd //execute - Rules one .java can have at most only one public class public class, if exists, name has to be same as filename execution entry is fixed public static void main (String[] args) 12345public class MyFirstApp&#123; public static void main (String[] args)&#123; system.out.print("I Rule!"); //statement &#125; //method&#125; //class - Commement123456789101112// single line comment/* mutiple lines comments*//** * mnutiple lines * can be interpreted by dos */ - Java keywords abstract continue for new switch assert*** default goto* package synchronized boolean do if private this break double implements protected throw byte else import public throws case enum** instanceof return transient catch extends int short try char final interface static void class finally long strictfp** volatile const* float native super while - Java Variables 12345int i = 10; // default inteiger long l1 = 8888888L; // 'L' is a must!float f = 12.3f; // 'f' is a mustdouble d1, d2, d3 = 0.123; // only d3 is given 0.123;String s = 'hello'; Smaller types of variables can be cast to larger types: byte, short, char -&gt; int -&gt; long -&gt; float -&gt; double 12345678910111213141516171819202122232425public class TestConvert &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int i1 = 123; int i2 = 456; double d1 = (i1+i2) * 1.2; // (i1+i2) -&gt;double float f1 = (float) ((i1+i2) * 1.2); // force casting byte b1 = 1; byte b2 = 2; byte b3 = (byte) (b1+b2); // auto casting to int first, must force cast back double d2 = 1e200; float f2 = (float) d2; // overflow System.out.println(f2); // become inf float f3 = 1.23f; long l1 = 123; //auto cast to int long l2 = 300000L; float f = l1 + l2 + f3; // auto cast to float first System.out.println(f); long l = (long) f; // forced to get rid of after=decimal System.out.println(l); &#125;&#125; - Java operators123456789101112131415/* binary oprators + - ! &amp; -------- and | -------- or ^ -------- 异或， 同false异true &amp;&amp; || ---- 短路与，短路或： 若左表达式能确定整体取值，则不计算右表达式*/// triple expressionint score = 80;String type = score &lt; 60 ? "fail!": "pass!"; // string +int c = 100;System.out.println('c = ' + c); // c will be auto cast to string - Others java uses unicode (UTF-16), 1 character always takses 2 bytes.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photo Test]]></title>
    <url>%2F2018%2F03%2F12%2FPhoto-Test%2F</url>
    <content type="text"><![CDATA[Photo link Test:]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Mongodb]]></title>
    <url>%2F2018%2F03%2F09%2Fmogodb-note%2F</url>
    <content type="text"><![CDATA[Below are some self-collected commonly-used commands. start12345678910# run in the backgroundmongod# open interactive shellmongo# in python from pymongo import MongoClientClient = MongoClient()db = Client[dbname] database12345678# basicshow dbsshow tables/collectiondb use db_name# delete current databasedb.dropDatabase() collection123456789# create collection db.createCollection("col_name")# create fixed collection with space 6142800 KB, documents &lt; 10000db.createCollection("col_name", &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; )# delete collectiondb.collection.drop() documents12345678910111213141516171819202122232425262728293031323334# insert documents (collection auto created if not exiested)db.collection.insertOne(&#123;"a": 3&#125;)db.collection.insert(&#123;"name":"MarcoCai"&#125;)# insert document indirectlydocument = &#123;...&#125;db.collection.insert(document)# inset multiple db.collection.insertMany([&#123;"b": 3&#125;, &#123;'c': 4&#125;])# find documents under a collectiondb.collection.find()db.collection.find().pretty()db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()db.col.find( &#123;$or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty()db.col.find(&#123;"likes": &#123;$gt:50&#125;, $or: [&#123;"by": "菜鸟教程"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;).pretty()# high level finddb.col.find(&#123;"title" : &#123;$type : 2&#125;&#125;)db.collection.find(query, &#123;title: 1, by: 1&#125;) // inclusion模式 指定返回的键，不返回其他键db.collection.find(query, &#123;title: 0, by: 0&#125;) // exclusion模式 指定不返回的键,返回其他键# update documentdb.test_collection.updateOne(&#123;"name":"abc"&#125;,&#123;$set:&#123;"age":"28"&#125;&#125;)db.test_collection.updateMany(&#123;"age":&#123;$gt:"10"&#125;&#125;,&#123;$set:&#123;"status":"xyz"&#125;&#125;)# replace documentdb.collection.save( &lt;document&gt; )# delete documentdb.inventory.deleteMany(&#123;&#125;)db.inventory.deleteMany(&#123; status : "A" &#125;)db.inventory.deleteOne( &#123; status: "D" &#125; ) symbol123456$gt -------- greater than &gt;$gte --------- gt equal &gt;=$lt -------- less than &lt;$lte --------- lt equal &lt;=$ne ----------- not equal !=$eq -------- equal = ObjectidMongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象。 由于 ObjectId 中保存了创建的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 getTimestamp 函数来获取文档的创建时间: 12var newObject = ObjectId()newObject.getTimestamp() data type 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。]]></content>
      <tags>
        <tag>database</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Database]]></title>
    <url>%2F2018%2F03%2F09%2FDatabase-knowledges%2F</url>
    <content type="text"><![CDATA[Useful links: nosql intro：http://www.runoob.com/mongodb/nosql.html Different kinds of databases summaries:https://www.jianshu.com/p/107c6b045245 pymongo:https://zhuanlan.zhihu.com/p/20500518 从MySQL和MongoDB的对比，看SQL与NoSQL的较量– 运维派:http://www.yunweipai.com/archives/23797.html SQL与mongoDB对比及映射:http://blog.csdn.net/leshami/article/details/52692912]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Mac Command Line]]></title>
    <url>%2F2018%2F03%2F08%2FMac-command-line%2F</url>
    <content type="text"><![CDATA[Marking down some commonly used shell command: Mac 命令行命令history 显示命令历史列表[Tab] =命令行自动补全↑(Ctrl+p) 显示上一条命令↓(Ctrl+n) 显示下一条命令clear 清除 shell 提示屏幕exit 注销history 显示命令历史reset 刷新 shell 提示屏幕 Mac 命令行编辑快捷键↑(Ctrl+p) 显示上一条命令↓(Ctrl+n) 显示下一条命令!num 执行命令历史列表的第num条命令!! 执行上一条命令!?string? 执行含有string字符串的最新命令Ctrl+r 然后输入若干字符，开始向上搜索包含该字符的命令，继续按Ctrl+r，搜索上一条匹配的命令Ctrl+s 与Ctrl+r类似,只是正向检索Ctrl+f 光标向前移动一个字符,相当与-&gt;Ctrl+b 光标向后移动一个字符,相当与&lt;-opt+&lt;- 光标向前移动一个单词opt+-&gt; 光标向后移动一个单词ls !$ 执行命令ls，并以上一条命令的参数为其参数Ctrl+a 移动到当前行的开头Ctrl+e 移动到当前行的结尾Esc+b 移动到当前单词的开头Esc+f 移动到当前单词的结尾Ctrl+l 清屏Ctrl+u 剪切命令行中光标所在处之前的所有字符（不包括自身）Ctrl+k 剪切命令行中光标所在处之后的所有字符（包括自身）Ctrl+d 删除光标所在处字符Ctrl+h 删除光标所在处前一个字符Ctrl+y 粘贴刚才所删除的字符Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符）Ctrl+t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符Ctrl+v 插入特殊字符,如Ctrl+v+Tab加入Tab字符键Esc+t 颠倒光标所在处及其相邻单词的位置Ctrl+c 删除整行Ctrl+(x u) 按住Ctrl的同时再先后按x和u，撤销刚才的操作Ctrl+s 挂起当前shellCtrl+q 重新启用挂起的shell 下面的应用可能稍稍高级一点点!! - 上一条命令!-n - 倒数第N条历史命令!-n:p - 打印上一条命令（不执行）!?string？- 最新一条含有“string”的命令!-n:gs/str1/str2/ - 将倒数第N条命令的str1替换为str2，并执行（若不加g,则仅替换第一个）]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
