<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 148]]></title>
    <url>%2F2018%2F07%2F13%2FLeetCode-Challenge-log-148%2F</url>
    <content type="text"><![CDATA[148. Sort ListMerge sort: if head or head.next is none, return head. split the list from middle into A and B recursively merge sort A and B merge sorted A and sorted B Complexity: time: Nlog(N) space: recursion call is at most log(N) deep, hence log(N) Sort a linked list in O(n log n) time using constant space complexity. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Soulution:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ # split and return two heads def split(head): if head is None: return None, None slow = fast = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next ha = head hb = slow.next slow.next = None return ha, hb # merge two list def merge(ha, hb): if not ha and not hb: return None head = ListNode(0) cur = head while ha and hb: if ha.val &lt;= hb.val: cur.next = ha ha = ha.next else: cur.next = hb hb = hb.next cur = cur.next if ha: cur.next = ha elif hb: cur.next = hb return head.next # sort def sort(head): if head is None or head.next is None: return head else: ha, hb = split(head) sa = sort(ha) sb = sort(hb) return merge(sa,sb) return sort(head)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
        <tag>merge sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 146]]></title>
    <url>%2F2018%2F07%2F12%2FLeetCode-Challenge-log-146%2F</url>
    <content type="text"><![CDATA[146. LRU CacheAnalysis: Although the problem only asks for implementing two operaions. It actually requires more than that. The two obvious and a few hidden required operations are: get: access value by key in O(1) and update its “freshness” put: add (key, value) pair in data structure and set it to be the freshest delete: delete the least recently used pair update: update pair’s value and “freshness” = delete and move to end First, if we want “get” to be done in O(1), hashing is a must. And we need to keep track of the “least recently used” element, hence a queue (FIFO) is considered. But if queue is used, updating the freshness of the pair will cost linear time, which is why a linklist should be used. So we can use hashing to map key to a node, where the value is saved. To update a node’s freshness from the linklist, we need to delete it from its original position, for which we need to not only know its next but also its pre — so we need to used double linklist! Finally, to delete the LRU from the hash table, we also need the key stored in the coresponding node. So now we have somthing like: hash key 1 key 2 key 3 … double linklist (k1, v1) (k2, v2) (k3, v3) … Trick: Python has a class collections.OrderedDict(), which is a dict that keeps track of the insertion order… Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 Soulution:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class ListNode: def __init__(self, k, v): self.next = None self.pre = None self.key = k self.val = v class LRUCache: def __init__(self, capacity): self.map = &#123;&#125; self.cap = capacity self.head = h = ListNode(None, None) self.tail = t = ListNode(None, None) h.next = t t.pre = h def get(self, key): if key not in self.map: return -1 else: node = self.map[key] self._delete(node) self._add(node) return node.val def put(self, key, value): # delete old key if exists if key in self.map: node = self.map[key] self._delete(node) del self.map[key] # delete LRU if full if len(self.map) == self.cap: lru = self.head.next self._delete(lru) del self.map[lru.key] # add it node = ListNode(key, value) self._add(node) self.map[key] = node def _delete(self, node): node.pre.next = node.next node.next.pre = node.pre def _add(self, node): n = self.tail p = self.tail.pre node.next = n node.pre = p p.next = node n.pre = node 123456789101112131415161718192021# collections.OrderedDict()class LRUCache: def __init__(self, capacity): self.map = collections.OrderedDict() self.cap = capacity def get(self, key): if key not in self.map: return -1 else: self.map.move_to_end(key) return self.map[key] def put(self, key, value): if key in self.map: self.map.move_to_end(key) self.map[key] = value else: if len(self.map) == self.cap: self.map.popitem(last = False) self.map[key] = value]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
        <tag>hash</tag>
        <tag>double linklist</tag>
        <tag>great problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 142]]></title>
    <url>%2F2018%2F07%2F12%2FLeetCode-Challenge-log-142%2F</url>
    <content type="text"><![CDATA[142. Linked List Cycle II Algorithm: find the loop and record where slow and fast hit set slow = head start traverse again, until the pointers hit again Analysis: When they first hit, fast is x steps ahead of slow, where x = k * len(loop). So in the second traverse, when slow first enter the loop, fast is exatcly k circles ahead and hit slow again. Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up:Can you solve it without using extra space? Soulution:1234567891011121314151617181920212223242526class Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None # find loop and note that pos[where they hit] - pos[head] = k*len(loop) loop = False slow = fast = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next if slow == fast: loop = True break if not loop: return None # find entry fast = slow slow = head while slow != fast: fast = fast.next slow = slow.next return slow]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 147]]></title>
    <url>%2F2018%2F07%2F12%2FLeetCode-Challenge-log-147%2F</url>
    <content type="text"><![CDATA[147. Insertion Sort ListAlgorithm: Insertion sort Trick: If a node is greater than the sorted tail, make it the new tail and move on to next. Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Soulution:1234567891011121314151617181920212223242526272829303132333435class Solution: def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None newhead = ListNode(0) newhead.next = head sort = head cur = head.next while cur: # quick check if cur &gt; sort if cur.val &gt; sort.val: sort = cur cur = cur.next continue # delete cur nxt = cur.next sort.next = nxt # insert cur pos = newhead while pos != sort and cur.val &gt; pos.next.val: pos = pos.next temp = pos.next pos.next = cur cur.next = temp # update cur cur = nxt return newhead.next]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 160]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-160%2F</url>
    <content type="text"><![CDATA[160. Intersection of Two Linked Lists Algorithm1: traverse both lists and count len(a) and len(b) chop |len(b) - len(a)| nodes from the head of the longer list travese both lists simutaneously until two pointers hit Algorithm2: let A = A+B, B = B+A such that two lists are alighn by their tails travese both lists simutaneously until two pointers hit Analysis: Both algs align the two lists by their tails. Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Soulution:123456789101112131415161718192021222324252627282930313233343536373839# alg 1class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ # measure len cur = headA lenA = 0 while cur: lenA += 1 cur = cur.next cur = headB lenB = 0 while cur: lenB += 1 cur = cur.next # make 2 the same len if lenA &gt; lenB: while lenA &gt; lenB: headA = headA.next lenA -= 1 else: while lenB &gt; lenA: headB = headB.next lenB -= 1 # check one by one: while headA: if headA == headB: return headA else: headA = headA.next headB = headB.next return None 12345678910111213141516171819# alg 2class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None pa = headA pb = headB while pa != pb: # either hit or end up both None if not pa: pa = headB else: pa = pa.next if not pb: pb = headA else: pb = pb.next return pa]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 141]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-141%2F</url>
    <content type="text"><![CDATA[141. Linked List Cycle Classic application of two pointers: slow and fast. Algorithm: when fast catches up with slow, there is cycle. Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? Soulution:1234567891011121314151617class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False slow = head fast = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 21]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-21%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted ListsBasic linklist operation. Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Soulution:123456789101112131415161718192021class Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ res = ListNode(0) cur = res while l1 and l2: if l1.val &lt;= l2.val: cur.next = l1 cur = cur.next l1 = l1.next else: cur.next = l2 cur = cur.next l2 = l2.next if l1: cur.next = l1 if l2: cur.next = l2 return res.next]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 143]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-143%2F</url>
    <content type="text"><![CDATA[143. Reorder ListAlgorithm: split the linklist reverse the second half merge one by one Given a singly linked list L: L0→L1→…→L**n-1→Ln,reorder it to: L0→L**n→L1→L**n-1→L2→L**n-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: 1Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: 1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. Soulution:123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def reorderList(self, head): """ :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. """ if not head or not head.next: pass else: # return node at len // 2 newHead = ListNode(0) newHead.next = head slow = newHead fast = newHead while fast.next and fast.next.next: fast = fast.next.next slow = slow.next mid = slow # reverse the second half as head2 tail = None cur = mid.next mid.next = None # important! aviod cycle!!! while cur: nxt = cur.next cur.next = tail tail = cur cur = nxt head2 = tail # link one by one p1 = head p2 = head2 res = ListNode(0) cur = res while p1 or p2: if p1: cur.next = p1 cur = cur.next p1 = p1.next if p2: cur.next = p2 cur = cur.next p2 = p2.next]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 61]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-61%2F</url>
    <content type="text"><![CDATA[61. Rotate ListAnalysis: It is equivalent to finding the last k nodes and make them the head. If k &gt; len(list), k = k % len(list) Algorithm: let fast be k steps ahead of slow. forward both pointer until fast is the last node now slow is the pre of the last kth node Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: 12345Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: 1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL Soulution:123456789101112131415161718192021222324252627282930313233343536373839class Solution: def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if k == 0 or not head: return head newHead = ListNode(0) newHead.next = head # fast is k ahead of slow slow = newHead fast = newHead count = 0 while count &lt; k: if fast.next: fast = fast.next count += 1 else: fast = newHead k = k % count count = 0 if k == 0: return head # slow is the pre of the new head while fast.next: fast = fast.next slow = slow.next # paste if slow == newHead: return head else: fast.next = head res = slow.next slow.next = None return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 92]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-92%2F</url>
    <content type="text"><![CDATA[92. Reverse Linked List IIAlgorithm: find (m-1)th node reverse (n-m+1) nodes Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL Soulution:123456789101112131415161718192021222324252627282930313233343536class Solution: def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head # build virture head to aviod bound problem virtureHead = ListNode(0) virtureHead.next = head head = virtureHead # find (m-1)th pre = head for i in range(m-1): pre = pre.next # reverse n-m+1 following elements tail = None cur = pre.next count = 0 while count &lt; n - m + 1: nxt = cur.next cur.next = tail tail = cur cur = nxt count += 1 # pm + tail + cur pre.next.next = cur pre.next = tail return head.next]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 206]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-206%2F</url>
    <content type="text"><![CDATA[206. Reverse Linked ListBasic linklist operation. It can be done either recursively or iteritively. Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Soulution:1234567891011121314# Recursiveclass Solution: def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ # reverse and return head and tail if not head or not head.next: return head newHead = self.reverseList(head.next) head.next.next = head head.next = None return newHead 123456789101112131415# iterativelyclass Solution: def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ cur = head tail = None while cur: nxt = cur.next cur.next = tail tail = cur cur = nxt return tail]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 83]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-83%2F</url>
    <content type="text"><![CDATA[83. Remove Duplicates from Sorted ListAlgorithms: while traverse the link, delete cur if cur == cur.next. Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: 12Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 Soulution:1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head cur = head while cur and cur.next: if cur.next.val == cur.val: cur.next = cur.next.next else: cur = cur.next return head]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 19]]></title>
    <url>%2F2018%2F07%2F11%2FLeetCode-Challenge-log-19%2F</url>
    <content type="text"><![CDATA[19. Remove Nth Node From End of ListThe trick is to create two pointers. One is n steps faster. Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? Soulution:12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if head is None: return None # slow = fast - n fast = head slow = head while n &gt; 0: fast = fast.next n -= 1 if fast is None: # if head is to be delete return head.next else: # otherwise while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 7]]></title>
    <url>%2F2018%2F07%2F05%2FLeetCode-Challenge-log-7%2F</url>
    <content type="text"><![CDATA[7. Reverse IntegerNormal question, but be aware of the upper bound and lower bound. Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Soulution:123456789101112131415161718192021222324252627class Solution: def reverse(self, x): """ :type x: int :rtype: int """ def maxint(): m = 1 for i in range(31): m = m &lt;&lt; 1 return -m, m-1 s = str(x) if s[0] == '-': sign = -1 s = s[1:] else: sign = +1 lb, ub = maxint() # print(lb, ub) x = int(s[::-1]) x = sign * x if x &lt; lb or x&gt; ub: x = 0 return x]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 2]]></title>
    <url>%2F2018%2F07%2F05%2FLeetCode-Challenge-log-2%2F</url>
    <content type="text"><![CDATA[2. Add Two Numbers Use recursion to process node by node. When there is carry, create a new node with val = 1 to add on. You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Soulution:1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 is None: return l2 if l2 is None: return l1 val = l1.val + l2.val if val &gt;= 10: val -= 10 l1.val = val l1.next = self.addTwoNumbers(self.addTwoNumbers(l1.next, ListNode(1)), l2.next) else: l1.val = val l1.next = self.addTwoNumbers(l1.next, l2.next) return l1]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 167]]></title>
    <url>%2F2018%2F06%2F25%2FLeetCode-Challenge-log-167%2F</url>
    <content type="text"><![CDATA[167. Two Sum II - Input array is sortedSame as #1, #653. Either use set or two pointers. Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 123Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. Soulution:123456789101112131415161718class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ l = 0 r = len(numbers) - 1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: return [l+1, r+1] elif s &lt; target: l += 1 else: r -= 1 return None]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>two sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 653]]></title>
    <url>%2F2018%2F06%2F25%2FLeetCode-Challenge-log-653%2F</url>
    <content type="text"><![CDATA[653. Two Sum IV - Input is a BSTsolution 1: use set. solution 2: use the fact that a sorting array is given. Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False Soulution:123456789101112131415161718192021222324class Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ def inorder(root, arr): if root is None: pass else: inorder(root.left, arr) arr.append(root.val) inorder(root.right, arr) arr = [] inorder(root, arr) count = set() for i in arr: if k-i not in count: count.add(i) else: return True return False 123456789101112131415161718192021222324252627class Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ def inorder(root, arr): if root is None: pass else: inorder(root.left, arr) arr.append(root.val) inorder(root.right, arr) arr = [] inorder(root, arr) l = 0 r = len(arr) - 1 while l &lt; r: if arr[l] + arr[r] == k: return True elif arr[l] + arr[r] &lt; k: l += 1 else: r -= 1 return False]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>two sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 374]]></title>
    <url>%2F2018%2F06%2F22%2FLeetCode-Challenge-log-374%2F</url>
    <content type="text"><![CDATA[374. Guess Number Higher or LowerNo explainaton needed. It is a good code template for BS. We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): 123-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example: 123n = 10, I pick 6.Return 6. Soulution:1234567891011121314151617181920212223# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): """ :type n: int :rtype: int """ low = 1 high = n while low &lt; high: mid = (low + high) // 2 g = guess(mid) if g == 0: return mid elif g == 1: low = mid + 1 else: high = mid return low]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 658]]></title>
    <url>%2F2018%2F06%2F22%2FLeetCode-Challenge-log-658%2F</url>
    <content type="text"><![CDATA[658. Find K Closest ElementsIt has some problems with test cases so can’t get it ac. Whatever, I have the correct code anyway… Binary search to locate the position Create a len(k) sliding window start from the position, slide it left until the furthest distance starts to increase. Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1: 12Input: [1,2,3,4,5], k=4, x=3Output: [1,2,3,4] Example 2: 12Input: [1,2,3,4,5], k=4, x=-1Output: [1,2,3,4] Note: The value k is positive and will always be smaller than the length of the sorted array. Length of the given array is positive and will not exceed 104 Absolute value of elements in the array and x will not exceed 104 Soulution:1234567891011121314151617181920212223242526272829303132333435363738class Solution: def findClosestElements(self, arr, k, x): """ :type arr: List[int] :type k: int :type x: int :rtype: List[int] """ def bs(arr, x): low = 0 high = len(arr) - 1 while low &lt; high: mid = (low + high) // 2 if arr[mid] &lt; x: low = mid + 1 else: high = mid return low # slide window pivot = bs(arr, x) left = pivot right = left + k - 1 if right &gt;= len(arr): left = left - (right - (len(arr) - 1)) right = len(arr) - 1 min_dis = max(abs(arr[left]-x), abs(arr[right] -x)) while left &gt;= 0 and right &gt;= pivot - 1: cur_dis = max(abs(arr[left]-x), abs(arr[right] -x)) # print(left, right, cur_dis) if cur_dis &lt;= min_dis: min_dis = cur_dis left -= 1 right -= 1 else: break return arr[left + 1: right + 2]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 719]]></title>
    <url>%2F2018%2F06%2F22%2FLeetCode-Challenge-log-719%2F</url>
    <content type="text"><![CDATA[719. Find K-th Smallest Pair DistanceRelated problem: #378, # 668. The difference is how to count how many smaller. To count quickly, you need to: Sort the array first. Do a while loop within a for loop; Each time the element that just gives enough distance to the one that in the outer loop; For next iteration, start looking from the last element found to save time. Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1: 12345678910Input:nums = [1,3,1]k = 1Output: 0 Explanation:Here are all the pairs:(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2Then the 1st smallest distance pair is (1,1), and its distance is 0. Note: 2 &lt;= len(nums) &lt;= 10000. 0 &lt;= nums[i] &lt; 1000000. 1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. Soulution:123456789101112131415161718192021222324252627282930class Solution: def smallestDistancePair(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ nums = sorted(nums) n = len(nums) ### Important part def countLower(mid): count = 0 lb = 0 for i in range(n): while nums[i] - nums[lb] &gt; mid: lb += 1 count += (i - lb) return count ### ---------------- low = 0 high = nums[-1] - nums[0] while low &lt; high: mid = (low + high) // 2 if countLower(mid) &lt; k: low = mid + 1 else: high = mid return low]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 668]]></title>
    <url>%2F2018%2F06%2F21%2FLeetCode-Challenge-log-668%2F</url>
    <content type="text"><![CDATA[668. Kth Smallest Number in Multiplication TableSimilar to #378: http://localhost:4000/2018/06/21/LeetCode-Challenge-log-378/, except now we can count how many smaller faster in O(n) time! There is also two tricks to achieve 99% beaten: Switch m and n if m &gt; n. So it can count faster Do not use build-in min() but if statement. Too many function calls slows down the speed. Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table. Example 1: 123456789Input: m = 3, n = 3, k = 5Output: Explanation: The Multiplication Table:1 2 32 4 63 6 9The 5-th smallest number is 3 (1, 2, 2, 3, 3). Example 2: 12345678Input: m = 2, n = 3, k = 6Output: Explanation: The Multiplication Table:1 2 32 4 6The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6). Note: The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n] Soulution:1234567891011121314151617181920212223242526272829from heapq import *class Solution: def findKthNumber(self, m, n, k): """ :type m: int :type n: int :type k: int :rtype: int """ def countLower(m, n, num): count = 0 for row in range(1, min(m, num) + 1): temp = num // row if temp &gt; n: count += n else: count += temp return count if m &gt; n: n, m = m, n high = m * n low = 1 while low &lt; high: mid = (low + high) // 2 if countLower(m, n, mid) &lt; k: low = mid + 1 else: high = mid return low]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 378]]></title>
    <url>%2F2018%2F06%2F21%2FLeetCode-Challenge-log-378%2F</url>
    <content type="text"><![CDATA[378. Kth Smallest Element in a Sorted MatrixSimilar to #373: https://marcopolocai.github.io/2018/06/20/LeetCode-Challenge-log-373/. However, because all we want is just the kth number, we can use a binary-search-like approach to make a guess and count if it has k-1 lower numbers. It is a faster approach but very tricky to implement, as you has to be very careful on the boundary. Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Note: You may assume k is always valid, 1 ≤ k ≤ n2. Soulution:12345678910111213141516171819202122232425# piority queue approachimport heapq as hqclass Solution: def kthSmallest(self, matrix, k): """ :type matrix: List[List[int]] :type k: int :rtype: int """ if not matrix: return None n = len(matrix) count = 0 visited = set() heap = [(matrix[0][0], 0, 0)] while count &lt; k and len(heap)&gt;0: num, i, j = hq.heappop(heap) if (i+1 &lt; n) &amp; ((i+1, j) not in visited): hq.heappush(heap, (matrix[i+1][j], i+1, j)) visited.add((i+1, j)) if (j+1 &lt; n) &amp; ((i, j+1) not in visited): hq.heappush(heap, (matrix[i][j+1], i, j+1)) visited.add((i, j+1)) count += 1 return num 123456789101112131415161718192021222324252627282930313233# binary seach class Solution: def kthSmallest(self, matrix, k): """ :type matrix: List[List[int]] :type k: int :rtype: int """ def countLower(num, n, m): row = 0 col = m - 1 count = 0 while row &lt; n and col &gt;= 0: if matrix[row][col] &lt;= mid: count += col + 1 row += 1 else: col -= 1 return count n = len(matrix) low = matrix[0][0] high = matrix[-1][-1] while low &lt; high: mid = (low + high) // 2 count = countLower(mid, n, n) print(low, high, mid,count) if count &gt;= k: high = mid else: low = mid + 1 return low]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>heap</tag>
        <tag>priority queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding _ in Python]]></title>
    <url>%2F2018%2F06%2F21%2FUnderstanding-in-Python%2F</url>
    <content type="text"><![CDATA[When reading the python docs and source codes, I see there is lots of usage of “___” in naming and other places. So I google a bit and find two great articles for explanation. Here are the links and thank Chevalier and Shahriar for their great summaries : https://shahriar.svbtle.com/underscores-in-python https://segmentfault.com/a/1190000002611411]]></content>
      <tags>
        <tag>python</tag>
        <tag>underline</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 373]]></title>
    <url>%2F2018%2F06%2F20%2FLeetCode-Challenge-log-373%2F</url>
    <content type="text"><![CDATA[373. Find K Pairs with Smallest SumsTried many methods. Take it as a review to heap and piority queue… qsort —&gt; time limit exceed build min heap, pop the first k pairs —&gt; ac, beat 9% use max heap to maintain the k min pairs —&gt; ac, beat 14% use the fact that both arrays are presorted, and piority queue to maintain the candidates —&gt; ac, beat 52% use built-in library “heapq” —&gt; ac, beat 74% use set, instead of array to mark visted slots —&gt; ac, beat 95% You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. Example 1: 123456Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: 123456Given nums1 = [1,1,2], nums2 = [1,2,3], k = 2Return: [1,1],[1,1]The first 2 pairs are returned from the sequence:[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: 123456Given nums1 = [1,2], nums2 = [3], k = 3 Return: [1,3],[2,3]All possible pairs are returned from the sequence:[1,3],[2,3] Credits:Special thanks to @elmirap and @StefanPochmann for adding this problem and creating all test cases. Soulution:First we can visualize the all pairs as below: 0 1 2 3 0 added added added candidate 1 added candidate 2 candidate We observes that, for (i, j), only when (i-1, j) and (i, j-1) are added then it can be a candidate. With this lead, my solution keeps a piority queue, from which the min pair is popped out and then added to the ouput each time. Meanwhile we check if (i, j+1) or (i+1, j) is a valid candidate. If so, add it to the queue. Repeat until ouput has k pairs. 123456789101112131415161718192021222324252627from heapq import *class Solution: def kSmallestPairs(self, nums1, nums2, k): """ :type nums1: List[int] :type nums2: List[int] :type k: int :rtype: List[List[int]] """ ncol = min(k, len(nums2)) nrow = min(k, len(nums1)) if ncol == 0 or nrow == 0:return [] mark = set() cand = [(nums1[0] + nums2[0] ,0,0)] res = [] while len(res) &lt; k and len(cand) &gt; 0: s, i, j = heappop(cand) res.append([nums1[i], nums2[j]]) mark.add((i, j)) if i+1 &lt; nrow and ((j-1&gt;=0 and (i+1, j-1) not in mark) or (j-1 &lt; 0)): heappush(cand, (nums1[i+1] + nums2[j], i+1, j)) if j+1 &lt; ncol and ((i-1&gt;=0 and (i-1, j+1) not in mark) or (i-1 &lt; 0)): heappush(cand, (nums1[i] + nums2[j+1], i, j+1)) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>heap</tag>
        <tag>priority queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Sorting] Heap Sort]]></title>
    <url>%2F2018%2F06%2F19%2FSorting-Heap-Sort%2F</url>
    <content type="text"><![CDATA[heap.img Pre-req.Binary tree: Every node at most has two kids. Full binary tree: Every level is full. K levels ⟺ 2^K-1 nodes. Complete binary tree: Except the last level, all levels are full. Because of the above properties, it can be represented by an array, where left = root*2, right = root*2 +1, and root = kid // 2. Becasue of array is usually zero- based, the below formulas are used in heap instead: left = root*2 + 1, right = root*2 + 2, and root = (kid-1) // 2 HeapMax (min) Heap is a complete binary tree where father nodes must be greater (smaller) than their children nodes. * the codes below use min heap for default. Piority queueA piority queue, where its element are tuples like (piority, item), is just a special heap. In python, because tuple comparision is available, heap is quivalent piority queue! Operations on HeapHeapify(array, i)It adjust the tree under index i, making sure the ith element sinks down to its correct place. 123456789101112131415# use recursiondef heapify(arr, i): root = i left = 2 * i + 1 right = 2 * i + 2 if right &lt; len(arr) and arr[right] &lt; arr[left] and arr[right] &lt; arr[root]: # swap root and right arr[right], arr[root] = arr[root], arr[right] heapify(arr, right) elif left &lt; len(arr) and arr[left] &lt; arr[root]: # swap left and root arr[left], arr[root] = arr[root], arr[left] heapify(arr, left) else: pass or 12345678910111213141516# use while loopdef heapify_loop(arr, i) root = i while root &lt; len(arr): left = 2 * root + 1 right = 2 * root + 2 if right &lt; len(arr) and arr[right] &lt; arr[left] and arr[right] &lt; arr[root]: # swap root and right arr[right], arr[root] = arr[root], arr[right] root = right elif left &lt; len(arr) and arr[left] &lt; arr[root]: # swap left and root arr[left], arr[root] = arr[root], arr[left] root = left else: break Build_heap(array)This done by calling heapify(arr, i) from the bottom to the top, ensureing the array satisfies the heap property. 123def build_heap(arr): for i in range( (len(arr)-1) // 2, -1, -1): heapify(arr, i) Insert(array, ele)This is done by adding the heap to the end, and sift it up to the correct position. 1# omiited Pop(array)This is done by: poping the root of the heap fill the root with the last element in the array heapify(arr, 0) 123456789def pop(arr): if arr == []: return None else: temp = arr[0] arr[0] = arr[-1] del arr[-1] heapify(arr, 0) return temp Notice keep popping will give a ordered array. Heapsort(array):The complete sorting process includes build the heap ouput the min(max) of the heap one at a time to form a ordered array 12345678def heapsort(arr): build_heap(arr) res = [] temp = pop(arr) while temp is not None: res.append(temp) temp = pop(arr) return res PerformanceEach Heapify is log(n). Building heap does n times of Heapify, hence nlog(n). Each Pop calls Heapify once, hence log(n). Totally there are n times of popping, hence nlog(n). ⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎⬇︎ Worst = 2*nlog(n) = O(nlog(n)) Ref. http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/ http://blog.51cto.com/jx610/1702260]]></content>
      <tags>
        <tag>heap</tag>
        <tag>priority queue</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Challenge log 606]]></title>
    <url>%2F2018%2F06%2F18%2FLeetcode-Challenge-log-606%2F</url>
    <content type="text"><![CDATA[606. Construct String from Binary TreeSimple DFS. You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: 123456789101112Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;. Example 2: 1234567891011Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relation Soulution:12345678910111213141516class Solution: def tree2str(self, t): """ :type t: TreeNode :rtype: str """ if t is None: return '' elif t.right is None and t.left is None: return str(t.val) elif t.left is None: return str(t.val) + '()' + '(' + self.tree2str(t.right) + ')' elif t.right is None: return str(t.val) + '(' + self.tree2str(t.left) + ')' else: return str(t.val) + '(' + self.tree2str(t.left) + ')' + '(' + self.tree2str(t.right) + ')']]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plotly: beautiful graph-building tool]]></title>
    <url>%2F2018%2F06%2F15%2FPlotly-beautiful-graph-building-tool%2F</url>
    <content type="text"><![CDATA[Found this super powerful graphing tool by chance. It satisfies a few key demands: It builds interative beautiful plots. It can output as html or embeddable html code. It also offer a online mode to view plots through a dashboard and to embed plots through its api, if data safety is not a big concern. Ref: https://plot.ly/python/#fundamentals https://images.plot.ly/plotly-documentation/images/python_cheat_sheet.pdf Below are some small example usage… I. juhpyter notebook inline1234567891011121314import plotlyimport plotly.offline as pyfrom plotly import graph_objs as goimport numpy as nppy.init_notebook_mode(connected=True)# Simple sine functionx = np.linspace(0,2*np.pi)y = np.sin(x)trace = go.Scatter(x=x,y=y)layout = go.Layout(title = 'title goes here')fig = go.Figure(data = [trace], layout = layout)py.iplot(fig) II. output as html123456789import plotlyimport plotly.graph_objs as goimport plotly.plotly as pyplotly.offline.plot(&#123; "data": [go.Scatter(x=[1, 2, 3, 4], y=[4, 3, 2, 1])], "layout": go.Layout(title="hello world")&#125;) III. aquire embeddable html code*for example page, check “Plotly: show page.html” *to embed, must include .js link in the head of the html 12345678import plotlyimport plotly.graph_objs as godata = [&#123;"x": [1, 2, 3], "y": [3, 1, 6]&#125;]layout = go.Layout( title='Simple example')fig = go.Figure(data=data, layout=layout)plotly.offline.plot(fig, include_plotlyjs=False, output_type='div')]]></content>
      <tags>
        <tag>plotly</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plotly: show page]]></title>
    <url>%2F2018%2F06%2F15%2FPlotly-show-page%2F</url>
    <content type="text"><![CDATA[window.PLOTLYENV=window.PLOTLYENV || {};window.PLOTLYENV.BASE_URL="https://plot.ly";Plotly.newPlot("8d97d7bf-8774-4617-afdb-12d2c63e10fb", [{"marker": {"color": "rgb(55, 83, 109)"}, "type": "bar", "y": [219, 146, 112, 127, 124, 180, 236, 207, 236, 263, 350, 430, 474, 526, 488, 537, 500, 439], "x": [1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012], "name": "Rest of world"}, {"marker": {"color": "rgb(26, 118, 255)"}, "type": "bar", "y": [16, 13, 10, 11, 28, 37, 43, 55, 56, 88, 105, 156, 270, 299, 340, 403, 549, 499], "x": [1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012], "name": "China"}], {"legend": {"bgcolor": "rgba(255, 255, 255, 0)", "bordercolor": "rgba(255, 255, 255, 0)", "x": 0, "y": 1.0}, "yaxis": {"tickfont": {"color": "rgb(107, 107, 107)", "size": 14}, "title": "USD (millions)", "titlefont": {"color": "rgb(107, 107, 107)", "size": 16}}, "barmode": "group", "xaxis": {"tickfont": {"color": "rgb(107, 107, 107)", "size": 14}}, "bargroupgap": 0.1, "title": "US Export of Plastic Scrap", "bargap": 0.15}, {"showLink": true, "linkText": "Export to plot.ly"})window.addEventListener("resize", function(){Plotly.Plots.resize(document.getElementById("8d97d7bf-8774-4617-afdb-12d2c63e10fb"));});]]></content>
      <tags>
        <tag>plotly</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 696]]></title>
    <url>%2F2018%2F06%2F14%2FLeetCode-Challenge-log-696%2F</url>
    <content type="text"><![CDATA[696. Count Binary Substrings First solution first finds a boundary st.”01” and then extends the string to both sides to check if qualified. Optimal Solution keeps counting how many contegious ‘0’ and ‘1’ currently and previously to achieve O(n) time and O(1) space. Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: 1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. Example 2: 123Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&apos;s and 0&apos;s. Note: s.length will be between 1 and 50,000. s will only consist of “0” or “1” characters. Soulution:123456789101112131415class Solution: def countBinarySubstrings(self, s): """ :type s: str :rtype: int """ res = 0 for i in range(len(s) - 1): if s[i] != s[i + 1]: res += 1 j = 1 while (i-j &gt;= 0) and (i+1+j &lt; len(s)) and (s[i-j] != s[i+1+j]) and (s[i-j] == s[i]): res += 1 j += 1 return res 123456789101112131415161718class Solution: def countBinarySubstrings(self, s): """ :type s: str :rtype: int """ res = 0 curLen = 1 preLen = 0 for i in range(1, len(s)): if s[i] == s[i-1]: curLen += 1 else: preLen = curLen curLen = 1 if curLen &lt;= preLen: res += 1 return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 788]]></title>
    <url>%2F2018%2F06%2F10%2FLeetCode-Challenge-log-788%2F</url>
    <content type="text"><![CDATA[788. Rotated DigitsIt is a logic problem. My solution is: If it contains 3 4 7, it is invalid. If it contains only 0 1 8, it is valid but not different. The rest cases are passed. X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? 123456Example:Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. Note: N will be in range [1, 10000]. Soulution:12345678910111213141516class Solution: def rotatedDigits(self, N): """ :type N: int :rtype: int """ res = 0 for i in range(1, N+1): num = set(str(i)) if len(num &amp; &#123;'3', '4', '7'&#125;) &gt; 0: continue elif num &amp; &#123;'0', '1', '8'&#125; == num: continue else: res += 1 return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 448]]></title>
    <url>%2F2018%2F06%2F08%2FLeetCode-Challenge-log-448%2F</url>
    <content type="text"><![CDATA[448. Find All Numbers Disappeared in an ArrayThe quick and dirty solution is to use set/hashmap again. The other satisfied solution is using the sign of a number(+/-) to mark whether it shows up before, without extra space. Whoever came up with this really knows how to unitilize space… Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] Soulution:1234567891011class Solution: def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ n = len(nums) for i in range(n): index = abs(nums[i])-1 nums[index] = -abs(nums[index]) return [x for x in range(1, n+1) if nums[x-1]&gt;0] 12345678910111213class Solution: def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ n = len(nums) nums = set(nums) res = [] for i in range(1, n + 1): if i not in nums: res.append(i) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 389]]></title>
    <url>%2F2018%2F06%2F08%2FLeetCode-Challenge-log-389%2F</url>
    <content type="text"><![CDATA[389. Find the DifferenceBest solution is to use bitwise operation XOR: same ele will be cancel if xor twice. Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: 123456789Input:s = &quot;abcd&quot;t = &quot;abcde&quot;Output:eExplanation:&apos;e&apos; is the letter that was added. Soulution:123456789101112131415161718192021class Solution: def findTheDifference(self, s, t): """ :type s: str :type t: str :rtype: str """ count = &#123;&#125; for i in s: if i not in count: count[i] = 1 else: count[i] += 1 for i in t: if i not in count: return i else: count[i] -= 1 for key in count: if count[key] &lt; 0: return key 1234567891011class Solution: def findTheDifference(self, s, t): """ :type s: str :type t: str :rtype: str """ res = 0 for i in s + t: res ^= ord(i) return chr(res)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bit operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 690]]></title>
    <url>%2F2018%2F06%2F08%2FLeetCode-Challenge-log-690%2F</url>
    <content type="text"><![CDATA[690. Emplyee ImportanceBFS, one time AC You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his directsubordinates’ id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: 1234Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. Note: One employee has at most one direct leader and may have several subordinates. The maximum number of employees won’t exceed 2000. Soulution:1234567891011121314151617181920212223242526272829"""# Employee infoclass Employee: def __init__(self, id, importance, subordinates): # It's the unique id of each node. # unique id of this employee self.id = id # the importance value of this employee self.importance = importance # the id of direct subordinates self.subordinates = subordinates"""class Solution: def getImportance(self, employees, id): """ :type employees: Employee :type id: int :rtype: int """ lead = &#123;&#125; for emp in employees: lead[emp.id] = (emp.importance, emp.subordinates) queue = [id] res = 0 while len(queue) &gt; 0: cur = lead[queue.pop()] res += cur[0] queue += cur[1] return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 283]]></title>
    <url>%2F2018%2F06%2F08%2FLeetCode-Challenge-log-283%2F</url>
    <content type="text"><![CDATA[283. Move ZerosThe key is to use no extra space, hence swap is most convenient. To optimize operation, only swap when encounter zeroes. Given an array nums, write a function to move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. Example: 12Input: [0,1,0,3,12]Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Soulution:standard solution: 1234567891011121314class Solution: def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ cur = 0 tail = 0 n = len(nums) while cur &lt; n: if nums[cur] != 0: nums[cur], nums[tail] = nums[tail], nums[cur] tail += 1 cur += 1 my solution: 12345678910111213141516class Solution: def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if nums == []: return [] n = len(nums) i = 0 while i &lt; n : if nums[i] == 0: del nums[i] nums.append(0) n -= 1 i -= 1 i += 1]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 520]]></title>
    <url>%2F2018%2F06%2F08%2FLeetCode-Challenge-log-520%2F</url>
    <content type="text"><![CDATA[520. Detect CapitalEasy Level. Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”. Otherwise, we define that this word doesn’t use capitals in a right way. Example 1: 12Input: &quot;USA&quot;Output: True Example 2: 12Input: &quot;FlaG&quot;Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. Soulution:1234567891011121314151617181920class Solution: def detectCapitalUse(self, word): """ :type word: str :rtype: bool """ upper = [] for char in word: if ord(char) &lt; 97: upper.append(1) else: upper.append(0) if sum(upper) == len(word): return True elif sum(upper) == 0: return True elif sum(upper) == 1 and upper[0] == 1: return True else: return False]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UCSD course plan]]></title>
    <url>%2F2018%2F06%2F07%2FUCSD-course-plan%2F</url>
    <content type="text"><![CDATA[This is a note of the course plan for my master degree at UCSD. It’s planned to be finished in 4 quarters, temporarily. School: CSE@UCSD Major: CE75 Computer Science q1:obj: get used to new env get to know some prof, find research opportunity apply for phd practice on leetcode, prepare to apply for 2019 intern class: CSE 202 Algorithm Design &amp; Analysis Paturi Paturi CSE 254 Statistical Learning Dasgupta CSE 259 q2:q3:#####q4:]]></content>
      <tags>
        <tag>ucsd</tag>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gundam] Metal Build F91 MSV]]></title>
    <url>%2F2018%2F06%2F05%2FGundam-Metal-Build-F91%20MSV%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>gundam</tag>
        <tag>mb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 258]]></title>
    <url>%2F2018%2F05%2F29%2FLeetCode-Challenge-log-258%2F</url>
    <content type="text"><![CDATA[258. Add DigitsO(1) soulution: 12345 % 9 = (1+2+3+4+5) % 9. Based on a*10^k % 9 = a % 9. Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: 1234Input: 38Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up:Could you do it without any loop/recursion in O(1) runtime? Soulution:123456789class Solution: def addDigits(self, num): """ :type num: int :rtype: int """ if num == 0: return 0 elif num % 9 == 0: return 9 else: return num % 9]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 695]]></title>
    <url>%2F2018%2F05%2F21%2FLeetCode-Challenge-log-695%2F</url>
    <content type="text"><![CDATA[695. Max Area of IslandRecursive solution. Remember to check the seen slot. Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1‘s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 16 Note the answer is not 11, because the island must be connected 4-directionally. Example 2: 1[[0,0,0,0,0,0,0,0]] Given the above grid, return 10 Note: The length of each dimension in the given grid does not exceed 50. Soulution:123456789101112131415161718192021222324252627class Solution: def maxAreaOfIsland(self, grid): """ :type grid: List[List[int]] :rtype: int """ nrow = len(grid) ncol = len(grid[0]) def countArea(x, y): grid[x][y] = 0 cur = 1 if x + 1 &lt; nrow and grid[x + 1][y] == 1: cur += countArea(x + 1, y) if x - 1 &gt;= 0 and grid[x - 1][y] == 1: cur += countArea(x - 1, y) if y + 1 &lt; ncol and grid[x][y + 1] == 1: cur += countArea(x, y + 1) if y - 1 &gt;= 0 and grid[x][y - 1] == 1: cur += countArea(x, y - 1) return cur res = 0 for i in range(nrow): for j in range(ncol): if grid[i][j] == 1: res = max(res, countArea(i,j)) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>dis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 796]]></title>
    <url>%2F2018%2F05%2F19%2FLeetCode-Challenge-log-796%2F</url>
    <content type="text"><![CDATA[797. Rotate StringUse hash function to compare if B is a “rotate string” of A We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = &#39;abcde&#39;, then it will be &#39;bcdea&#39; after one shift on A. Return True if and only if A can become B after some number of shifts on A. 1234567Example 1:Input: A = &apos;abcde&apos;, B = &apos;cdeab&apos;Output: trueExample 2:Input: A = &apos;abcde&apos;, B = &apos;abced&apos;Output: false Note: A and B will have length at most 100. Soulution:123456789101112131415161718class Solution: def rotateString(self, A, B): """ :type A: str :type B: str :rtype: bool """ if A == '' and B == '': return True A2 = A + A n = len(A) shift = set() for i in range(n): shift.add(A2[i:i + n]) if B in shift: return True else: shift.remove(A2[i:i + n]) return False]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 812]]></title>
    <url>%2F2018%2F05%2F15%2FLeetCode-Challenge-log-812%2F</url>
    <content type="text"><![CDATA[812. Largest Triangle AreaViolent full traverse solution. You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. 12345Example:Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]Output: 2Explanation: The five points are show in the figure below. The red triangle is the largest. Notes: 3 &lt;= points.length &lt;= 50. No points will be duplicated. -50 &lt;= points[i][j] &lt;= 50. Answers within 10^-6 of the true value will be accepted as correct. Soulution:123456789101112131415161718class Solution: def largestTriangleArea(self, points): """ :type points: List[List[int]] :rtype: float """ res = 0 n = len(points) def area(p, q, r): return .5 * abs(p[0]*q[1]+q[0]*r[1]+r[0]*p[1] -p[1]*q[0]-q[1]*r[0]-r[1]*p[0]) for i in range(n): for j in range(i+1, n): for k in range(j+1 , n): res = max(res, area(points[i], points[j], points[k])) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gundam] MG ZZ (finished) 2]]></title>
    <url>%2F2018%2F05%2F09%2FGundam-MG-ZZ-finished-2%2F</url>
    <content type="text"><![CDATA[Total 2 months of assembling, painting, shooting and post-producing. Enjoy! I. MS mode II. MA mode]]></content>
      <tags>
        <tag>gundam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gundam] MG ZZ (finished)]]></title>
    <url>%2F2018%2F05%2F09%2FGundam-MG-ZZ-finished%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>gundam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 784]]></title>
    <url>%2F2018%2F05%2F08%2FLeetCode-Challenge-log-784%2F</url>
    <content type="text"><![CDATA[784. Letter Case PermutationRecursive solution. Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. 123456789Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;] Note: S will be a string with length at most 12. S will consist only of letters or digits. Soulution:123456789101112class Solution: def letterCasePermutation(self, S): """ :type S: str :rtype: List[str] """ if S == '': return [''] rest = self.letterCasePermutation(S[1:]) if 65 &lt;= ord(S[0]) &lt;= 122: return [S[0].lower() + x for x in rest] + [S[0].upper() + x for x in rest] else: return [S[0] + x for x in rest]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 762]]></title>
    <url>%2F2018%2F04%2F30%2FLeetCode-Challenge-log-762%2F</url>
    <content type="text"><![CDATA[762. Prime Number of Set Bits in Binary Representation Use info to calculate the poosible prime numbers . Traverse the list and see if the numbers have the desired number of ome bits. Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation. (Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits. Also, 1 is not a prime.) Example 1: 1234567Input: L = 6, R = 10Output: 4Explanation:6 -&gt; 110 (2 set bits, 2 is prime)7 -&gt; 111 (3 set bits, 3 is prime)9 -&gt; 1001 (2 set bits , 2 is prime)10-&gt;1010 (2 set bits , 2 is prime) Example 2: 123456789Input: L = 10, R = 15Output: 5Explanation:10 -&gt; 1010 (2 set bits, 2 is prime)11 -&gt; 1011 (3 set bits, 3 is prime)12 -&gt; 1100 (2 set bits, 2 is prime)13 -&gt; 1101 (3 set bits, 3 is prime)14 -&gt; 1110 (3 set bits, 3 is prime)15 -&gt; 1111 (4 set bits, 4 is not prime) Note: L, R will be integers L &lt;= R in the range [1, 10^6]. R - L will be at most 10000. Soulution:12345678910111213141516class Solution: def countPrimeSetBits(self, L, R): """ :type L: int :type R: int :rtype: int """ res = 0 prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23&#125; for i in range(L, R + 1): if self.countOneBits(i) in prime: res +=1 return res def countOneBits(self, n): return bin(n).count('1')]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 485]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-485%2F</url>
    <content type="text"><![CDATA[485. Max Consecutive OnesSelf explained. Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: 1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 Soulution:1234567class Solution: def findMaxConsecutiveOnes(self, nums): """ :type nums: List[int] :rtype: int """ return max([len(x) for x in ''.join([str(y) for y in nums]).split('0')]) or more pythonic: 1234567class Solution: def findMaxConsecutiveOnes(self, nums): """ :type nums: List[int] :rtype: int """ return max([len(x) for x in ''.join([str(y) for y in nums]).split('0')])]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 292]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-292%2F</url>
    <content type="text"><![CDATA[292. Nim GameIf n % 4 == 0, no matter how you act, your rival can make sure the next time you choose you still have n % 4 == 0. You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. Soulution:12345678class Solution: def canWinNim(self, n): """ :type n: int :rtype: bool """ if n == 0: return None return n % 4 != 0]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>IQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 136]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-136%2F</url>
    <content type="text"><![CDATA[136. Single Number Use hash table to mark element that shows before. Use math, 2 * sum of all unique number - sum of all. Use a XOR 0 = a, a XOR a =0. Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 Soulution:123456789101112131415# s1class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ uni = set() while len(nums) &gt; 0: num = nums.pop() if num in uni: uni.remove(num) else: uni.add(num) return uni.pop() 12345678# s2class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ return 2 * sum(set(nums)) - sum(nums) 12345678910# s3class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ for i in range(1, len(nums)): nums[0] = nums[0] ^ nums[i] return nums[0]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bit operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 693]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-693%2F</url>
    <content type="text"><![CDATA[693. Binary Number with Alterntive Bitss1. n&lt;&lt;1 + n should be all 1s. s2. similar to s1 but more pythonic s3. check by bit Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: 1234Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 Example 2: 1234Input: 7Output: FalseExplanation:The binary representation of 7 is: 111. Example 3: 1234Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. Example 4: 1234Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. Soulution:1234567891011class Solution: def hasAlternatingBits(self, n): """ :type n: int :rtype: bool """ res = True mask = 0 while mask &lt; n: mask = (mask &lt;&lt; 1) + 1 return (n &gt;&gt; 1) + n == mask 1234567class Solution: def hasAlternatingBits(self, n): """ :type n: int :rtype: bool """ return bin((n &gt;&gt; 1) + n).count('0') == 1 123456789101112131415class Solution: def hasAlternatingBits(self, n): """ :type n: int :rtype: bool """ res = [] while n &gt; 0: res.append(n % 2) n = n // 2 if len(res) &lt;= 1: return True for i in range(1, len(res)): if res[i] == res[i-1]: return False return True]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bit operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 104]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-104%2F</url>
    <content type="text"><![CDATA[104. Maximum Depth of Binary TreeRoot height = max(left height, right height) +1 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. Soulution:12345678class Solution: def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if root is None: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>binary tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 226]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-226%2F</url>
    <content type="text"><![CDATA[226. Invert Binary TreeDFS will do. Invert a binary tree. 12345 4 / \ 2 7 / \ / \1 3 6 9 to 12345 4 / \ 7 2 / \ / \9 6 3 1 Trivia:This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off. Soulution:123456789101112class Solution: def invertTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if root is None: return None tmp1 = self.invertTree(root.left) tmp2 = self.invertTree(root.right) root.left = tmp2 root.right = tmp1 return root]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 521]]></title>
    <url>%2F2018%2F04%2F29%2FLeetCode-Challenge-log-521%2F</url>
    <content type="text"><![CDATA[521. Longest Ucommon Subsequence IIf they are not equal, the answer will be the longer string; otherwise, answer is not-existed(-1). Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be anysubsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example 1: 12345Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. Note: Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. Soulution:1234567891011class Solution: def findLUSlength(self, a, b): """ :type a: str :type b: str :rtype: int """ if a == b: return -1 else: return max(len(a), len(b))]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 637]]></title>
    <url>%2F2018%2F04%2F28%2FLeetCode-Challenge-log-637%2F</url>
    <content type="text"><![CDATA[637. Average of Levels in Binary Trees1. Depth first traverse, record every node’s (value, level) s2. Width first traverse, keep two queues as parent level and kid level. Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example 1: 123456789Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note: The range of node’s value is in the range of 32-bit signed integer. Soulution: DFS 123456789101112131415161718192021class Solution: def averageOfLevels(self, root): """ :type root: TreeNode :rtype: List[float] """ if root is None: return [] res = &#123;&#125; self.dst(root, 0, res) return [res[i][0]/res[i][1] for i in range(len(res))] def dst(self, root, level, res): if root.left is not None: self.dst(root.left, level + 1, res) if root.right is not None: self.dst(root.right, level + 1, res) if level not in res: res[level] = [root.val, 1] else: res[level][0] += root.val res[level][1] += 1 WFS 123456789101112131415161718192021222324class Solution: def averageOfLevels(self, root): """ :type root: TreeNode :rtype: List[float] """ if root is None: return [] parents = [root] kids = [] tmp = 0 count = 0 res = [] while len(parents) != 0 or len(kids) != 0: parent = parents.pop(0) tmp += parent.val count += 1 if parent.left is not None: kids.append(parent.left) if parent.right is not None: kids.append(parent.right) if len(parents) == 0 : res.append(tmp/count) tmp = count = 0 parents = kids kids = [] return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 566]]></title>
    <url>%2F2018%2F04%2F28%2FLeetCode-Challenge-log-566%2F</url>
    <content type="text"><![CDATA[566. Reshape the MatrixUse python list slice and mod. In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: 123456789Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example 2: 12345678910Input: nums = [[1,2], [3,4]]r = 2, c = 4Output: [[1,2], [3,4]]Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix. Note: The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. Soulution:1234567891011class Solution: def matrixReshape(self, nums, r, c): """ :type nums: List[List[int]] :type r: int :type c: int :rtype: List[List[int]] """ if len(nums)*len(nums[0]) &lt; r*c: return nums nums = [num for row in nums for num in row] return [nums[i*c:i*c + c] for i in range(r)]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 766]]></title>
    <url>%2F2018%2F04%2F27%2FLeetCode-Challenge-log-766%2F</url>
    <content type="text"><![CDATA[766. Toeplitz MatrixSkip the first row and first column and traverse the matrix, check if m[i][j] = m[i-1][j-1]. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1: 12345678Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]Output: TrueExplanation:123451239512In the above grid, the diagonals are &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;, and in each diagonal all elements are the same, so the answer is True. Example 2: 1234Input: matrix = [[1,2],[2,2]]Output: FalseExplanation:The diagonal &quot;[1, 2]&quot; has different elements. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. Soulution:1234567891011121314class Solution: def isToeplitzMatrix(self, matrix): """ :type matrix: List[List[int]] :rtype: bool """ nrow = len(matrix) ncol = len(matrix[0]) for i in range(1, nrow): for j in range(1, ncol): if matrix[i-1][j-1] != matrix[i][j]: return False return True]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 463]]></title>
    <url>%2F2018%2F04%2F27%2FLeetCode-Challenge-log-463%2F</url>
    <content type="text"><![CDATA[463. Island Perimeters1: traverse all “1”, add the number of adjacent “0”s to the output. O(n) time. s2: check every adjacent pairs horizontally and vertically, add 1 to the ouput if the pair is (“0”, “1”). In other words, we are checking every edge to check if it is a border. O(n) time but neater. useful skill: map(list, zip(*grid)) = transpose(grid). You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example: 123456[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16 Soulution:12345678910111213141516171819class Solution: def islandPerimeter(self, grid): """ :type grid: List[List[int]] :rtype: int """ res = 0 nrow = len(grid) ncol = len(grid[0]) loc = [(0, 1), (0, -1), (1, 0), (-1, 0)] for i in range(nrow): for j in range(ncol): if grid[i][j] == 1: for a, b in loc: if i + a &gt;= nrow or i + a &lt; 0 or j + b &gt;= ncol or j + b &lt; 0: res += 1 elif grid[i + a][j + b] == 0: res += 1 return res 1234567891011class Solution: def islandPerimeter(self, grid): """ :type grid: List[List[int]] :rtype: int """ res = 0 res += sum([sum([a != b for a, b in zip(row + [0], [0] + row)]) for row in grid]) grid = map(list, zip(*grid)) res += sum([sum([a != b for a, b in zip(row + [0], [0] + row)]) for row in grid]) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 669]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode-Challenge-log-669%2F</url>
    <content type="text"><![CDATA[669. Trim a Binary Search TreeRecursive solution: Use the special property of binary search tree: left sons are smaller while right sons are greater. Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example 1: 123456789101112Input: 1 / \ 0 2 L = 1 R = 2Output: 1 \ 2 Example 2: 123456789101112131415161718Input: 3 / \ 0 4 \ 2 / 1 L = 1 R = 3Output: 3 / 2 / 1 Soulution:12345678910111213141516class Solution: def trimBST(self, root, L, R): """ :type root: TreeNode :type L: int :type R: int :rtype: TreeNode """ if root is None: return None if root.val &lt; L: return self.trimBST(root.right, L, R) if root.val &gt; R: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 575]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode-Challenge-log-575%2F</url>
    <content type="text"><![CDATA[575. Distribute CandiesSuper Straightforward. if candies kinds &gt; half of total, output the latter; otherwise the former. Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. Example 1: 123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. Example 2: 1234Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. The sister has two different kinds of candies, the brother has only one kind of candies. Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. Soulution:1234567class Solution: def distributeCandies(self, candies): """ :type candies: List[int] :rtype: int """ return min(len(set(candies)), len(candies)//2)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 682]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode-Challenge-log-682%2F</url>
    <content type="text"><![CDATA[682. Baseball GameStraightforward O(n). Use two run and O(1) space. Can use a stack to reduce to one run — O(n) space. You’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: Integer (one round’s score): Directly represents the number of points you get in this round. &quot;+&quot; (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points. &quot;D&quot; (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points. &quot;C&quot; (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed. Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example 1: 12345678Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&apos;s data was invalid. The sum is: 5. Round 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example 2: 1234567891011Input: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]Output: 27Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get -2 points. The sum is: 3.Round 3: You could get 4 points. The sum is: 7.Operation 1: The round 3&apos;s data is invalid. The sum is: 3. Round 4: You could get -4 points (the round 3&apos;s data has been removed). The sum is: -1.Round 5: You could get 9 points. The sum is: 8.Round 6: You could get -4 + 9 = 5 points. The sum is 13.Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. Soulution:1234567891011121314151617181920212223242526272829303132class Solution: def calPoints(self, ops): """ :type ops: List[str] :rtype: int """ i = 0 while i &lt; len(ops): op = ops[i] if op == "C": del ops[i] del ops[i-1] i -= 2 i += 1 res = 0 last = 0 secondlast = 0 for op in ops: if op == "D": secondlast = last last = last * 2 res += last elif op == "+": temp = last + secondlast secondlast = last last = temp res += last else: secondlast = last last = int(op) res += last return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 412]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode-Challenge-log-412%2F</url>
    <content type="text"><![CDATA[412. Fizz BuzzIt isn’t really interesting. Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: 1234567891011121314151617181920n = 15,Return:[ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot;] Soulution:123456789101112131415161718192021222324252627class Solution: def fizzBuzz(self, n): """ :type n: int :rtype: List[str] """ if n == 0: return None res = [] three = 0 five = 0 for i in range(1, n+1): three += 1 five += 1 if three == 3 and five == 5: three = 0 five = 0 res.append('FizzBuzz') elif three == 3: three = 0 res.append('Fizz') elif five == 5: five = 0 res.append('Buzz') else: res.append(str(i)) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 620]]></title>
    <url>%2F2018%2F04%2F25%2FLeetCode-Challenge-log-620%2F</url>
    <content type="text"><![CDATA[620. Department Top Three SalariesUse SQL wildcard with like . % is any length. _ is one character. Please write a SQL query to output movies with an odd numbered ID and a description that is not ‘boring’. Order the result by rating. For example, table cinema: 12345678910111213141516+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 1 | War | great 3D | 8.9 || 2 | Science | fiction | 8.5 || 3 | irish | boring | 6.2 || 4 | Ice song | Fantacy | 8.6 || 5 | House card| Interesting| 9.1 |+---------+-----------+--------------+-----------++---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 5 | House card| Interesting| 9.1 || 1 | War | great 3D | 8.9 |+---------+-----------+--------------+-----------+ Soulution:12345# Write your MySQL query statement belowselect *from cinemawhere id mod 2 = 1 and description not like &apos;%boring%&apos;order by rating desc]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 500]]></title>
    <url>%2F2018%2F04%2F25%2FLeetCode-Challenge-log-500%2F</url>
    <content type="text"><![CDATA[500. Keyboard RowUse dict to map charaters to row numbers. Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example 1: 12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. Soulution:12345678910111213141516171819202122232425class Solution: def findWords(self, words): """ :type words: List[str] :rtype: List[str] """ whichRow = &#123;&#125; res = [] rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'] for i, row in enumerate(rows): for char in row: whichRow[char] = i for word in words: if word == "": res.append(word) continue wordLow = word.lower() flag = True row = whichRow[wordLow[0]] for char in wordLow: if whichRow[char] != row: flag = False break if flag: res.append(word) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 557]]></title>
    <url>%2F2018%2F04%2F25%2FLeetCode-Challenge-log-557%2F</url>
    <content type="text"><![CDATA[557. Reverse Words in a String IIISelf explained. Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: 12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; Note: In the string, each word is separated by single space and there will not be any extra space in the string. Soulution:1234567class Solution: def reverseWords(self, s): """ :type s: str :rtype: str """ return ' '.join([x[::-1] for x in s.split(' ')])]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 476]]></title>
    <url>%2F2018%2F04%2F20%2FLeetCode-Challenge-log-476%2F</url>
    <content type="text"><![CDATA[476. Number Complement Use XOR 11111… to flip bit. Use Mask to decide which bits are 1s. Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1: 123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: 123Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Soulution:1234567891011class Solution: def findComplement(self, num): """ :type num: int :rtype: int """ mask = 1 while mask &lt;= num: mask = mask &lt;&lt; 1 mask -= 1 return num ^ mask 12345678910111213class Solution: def findComplement(self, num): """ :type num: int :rtype: int """ mask = 1 res = 0 for i in range(32): if 2**i &gt; num: break if mask &amp; num == 0: res += 2**i mask = mask &lt;&lt; 1 return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bit operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 806]]></title>
    <url>%2F2018%2F04%2F19%2FLeetCode-Challenge-log-806%2F</url>
    <content type="text"><![CDATA[806. Number of Lines To Write StringStraightforward. Python string ascii: ord() chr() We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, …, and widths[25] is the width of ‘z’. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2. 12345678Example :Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: [3, 60]Explanation: All letters have the same length of 10. To write all 26 letters,we need two full lines and one line with 60 units. 1234567891011Example :Input: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;bbbcccdddaaa&quot;Output: [2, 4]Explanation: All letters except &apos;a&apos; have the same length of 10, and &quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.For the last &apos;a&apos;, it is written on the second line becausethere is only 2 units left in the first line.So the answer is 2 lines, plus 4 units in the second line. Note: The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10]. Soulution:12345678910111213141516class Solution: def numberOfLines(self, widths, S): """ :type widths: List[int] :type S: str :rtype: List[int] """ cur = 0 res = 1 for s in S: charWidth = widths[ord(s)-ord('a')] cur += charWidth if cur &gt; 100: res += 1 cur = charWidth return [res, cur]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 627]]></title>
    <url>%2F2018%2F04%2F19%2FLeetCode-Challenge-log-627%2F</url>
    <content type="text"><![CDATA[627. Swap SalarySql if and case statement: update [table] set [column] = if ([condition], [v1], [v2] ) (see case example at the end) Given a table 1salary , such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table. For example: 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | m | 2500 || 2 | B | f | 1500 || 3 | C | m | 5500 || 4 | D | f | 500 | After running your query, the above salary table should have the following rows: 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | f | 2500 || 2 | B | m | 1500 || 3 | C | f | 5500 || 4 | D | m | 500 | Soulution:1UPDATE salary SET sex = IF(sex = &apos;m&apos;, &apos;f&apos;, &apos;m&apos;) 1234567-- alterUPDATE salarySET sex = CASE sex WHEN &apos;m&apos; THEN &apos;f&apos; ELSE &apos;m&apos; END; SQL case when1234567SELECT player_name, weight, CASE WHEN weight &gt; 250 THEN &apos;over 250&apos; WHEN weight &gt; 200 THEN &apos;201-250&apos; WHEN weight &gt; 175 THEN &apos;176-200&apos; ELSE &apos;175 or under&apos; END AS weight_group FROM benn.college_football_players]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 811]]></title>
    <url>%2F2018%2F04%2F18%2FLeetCode-Challenge-log-811%2F</url>
    <content type="text"><![CDATA[811. Subdomain Visit CountStraight forward. Use String.split() and collections.Counter()to prettify code. A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly. Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”. We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. 1234567Example 1:Input: [&quot;9001 discuss.leetcode.com&quot;]Output: [&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]Explanation: We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times. 1234567Example 2:Input: [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]Output: [&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]Explanation: We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times. Notes: The length of cpdomains will not exceed 100. The length of each domain name will not exceed 100. Each address will have either 1 or 2 “.” characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order. Soulution:1234567891011121314class Solution: def subdomainVisits(self, cpdomains): """ :type cpdomains: List[str] :rtype: List[str] """ ans = collections.Counter() for cpd in cpdomains: count, domains = cpd.split() domains = domains.split('.') for i in range(len(domains)): cur = '.'.join(domains[i:]) ans[cur] += int(count) return [' '.join([str(value),key]) for key, value in ans.items()]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 344]]></title>
    <url>%2F2018%2F04%2F15%2FLeetCode-Challenge-log-344%2F</url>
    <content type="text"><![CDATA[. pythonic s[::-1] recursive (memory limit exceed) swithch fisrt and last Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh”. Soulution:12345678910111213class Solution: def reverseString(self, s): """ :type s: str :rtype: str """ l = len(s) if l == 0: return "" elif l == 1: return s else: return s[-1] + self.reverseString(s[:-1]) 1234567891011121314class Solution: def reverseString(self, s): """ :type s: str :rtype: str """ s = list(s) i = 0 j = len(s) - 1 while i &lt; j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return ''.join(s)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 177]]></title>
    <url>%2F2018%2F04%2F13%2FLeetCode-Challenge-log-177%2F</url>
    <content type="text"><![CDATA[177. Nth Highest SalaryUse limit, offset, order by together Write a SQL query to get the nth highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. 12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200 |+------------------------+ Soulution:1234567891011121314CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN set N = N-1; RETURN ( # Write your MySQL query statement below. select distinct salary from Employee order by salary desc limit 1 offset N );END 123456789101112131415161718192021-- alterCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN set N=N-1; RETURN ( # Write your MySQL query statement below. select max(E.salary) from Employee E where E.salary not in ( select t.salary from ( select distinct A.salary from Employee A order by A.salary desc limit N ) as t ) );END]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
        <tag>need reviewed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 176]]></title>
    <url>%2F2018%2F04%2F13%2FLeetCode-Challenge-log-176%2F</url>
    <content type="text"><![CDATA[176. Second Highest SalaryUse limit, offset, order by together Write a SQL query to get the second highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null. 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ Soulution:12345select ifnull((select distinct salary from Employeeorder by salary desclimit 1 offset 1), null) as SecondHighestSalary 12345678-- alterselect max(E.salary) as SecondHighestSalaryfrom Employee Ewhere E.salary !=( select max(salary) as max from Employee)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
        <tag>need reviewed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 185]]></title>
    <url>%2F2018%2F04%2F13%2FLeetCode-Challenge-log-185%2F</url>
    <content type="text"><![CDATA[185. Department Top Three SalariesUse limit, offset, order by together The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. 12345678910+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 || 5 | Janet | 69000 | 1 || 6 | Randy | 85000 | 1 |+----+-------+--------+--------------+ The Department table holds all departments of the company. 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. 123456789+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || IT | Randy | 85000 || IT | Joe | 70000 || Sales | Henry | 80000 || Sales | Sam | 60000 |+------------+----------+--------+ Soulution:12 12]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
        <tag>need reviewed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 595]]></title>
    <url>%2F2018%2F04%2F12%2FLeetCode-Challenge-log-595%2F</url>
    <content type="text"><![CDATA[595. Big CountriesUnion is Faster then OR! There is a table World 123456789+-----------------+------------+------------+--------------+---------------+| name | continent | area | population | gdp |+-----------------+------------+------------+--------------+---------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000 || Albania | Europe | 28748 | 2831741 | 12960000 || Algeria | Africa | 2381741 | 37100000 | 188681000 || Andorra | Europe | 468 | 78115 | 3712000 || Angola | Africa | 1246700 | 20609294 | 100990000 |+-----------------+------------+------------+--------------+---------------+ A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million. Write a SQL solution to output big countries’ name, population and area. For example, according to the above table, we should output: 123456+--------------+-------------+--------------+| name | population | area |+--------------+-------------+--------------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+--------------+-------------+--------------+ Soulution:1234-- OR solutionselect name, population, area from Worldwhere area &gt; 3000000 or population &gt; 25000000 123456789101112-- Union solution( select name, population, area from World where area &gt; 3000000 )Union( select name, population, area from World where population &gt; 25000000)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 728]]></title>
    <url>%2F2018%2F04%2F10%2FLeetCode-Challenge-log-728%2F</url>
    <content type="text"><![CDATA[728. Self Dividing Numbershttps://leetcode.com/problems/self-dividing-numbers/description/ Nothing worth mentioned. A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed to contain the digit zero. Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible. Example 1: 123Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] Note: The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000. Soulution:123456789101112131415161718192021class Solution: def selfDividingNumbers(self, left, right): """ :type left: int :type right: int :rtype: List[int] """ if left &gt; right: return None res = [] for num in range(left, right + 1): flag = False can = num while num &gt; 0: r = num % 10 if r == 0 or can % r != 0: flag = True break num = num // 10 if not flag: res.append(can) return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 814]]></title>
    <url>%2F2018%2F04%2F10%2FLeetCode-Challenge-log-814%2F</url>
    <content type="text"><![CDATA[814. Binary Tree Pruninghttps://leetcode.com/problems/binary-tree-pruning/description/ Another DFS problem. We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) 1234567Example 1:Input: [1,null,0,0,1]Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.The diagram on the right represents the answer. 123Example 2:Input: [1,0,1,0,0,0,1]Output: [1,null,1,null,1] 123Example 3:Input: [1,1,0,1,1,0,1,0]Output: [1,1,0,1,1,null,1] Note: The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1. Soulution:1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pruneTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if root is None: return None l = self.pruneTree(root.left) r = self.pruneTree(root.right) if root.val == 0 and l is None and r is None: return None else: root.left = l root.right = r return root]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 184]]></title>
    <url>%2F2018%2F04%2F09%2FLeetCode-Challenge-log-184%2F</url>
    <content type="text"><![CDATA[184. Department Highest SalaryReview usage of in, exists The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. 12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ The Department table holds all departments of the company. 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department. 123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ Soulution:123456789-- existsselect D.name as Department, E.name as Employee, E.salary as Salaryfrom Employee E join Department D on E.DepartmentId = D.idwhere not exists( select * from Employee B where B.salary &gt; E.salary and B.DepartmentId = E.DepartmentId) 123456789-- inselect D.name as Department, E.name as Employee, E.salary as Salaryfrom Employee E join Department D on E.DepartmentId = D.idwhere (E.DepartmentId, E.salary) in( select E.DepartmentId, max(salary) from Employee E group by E.DepartmentId)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 617]]></title>
    <url>%2F2018%2F04%2F09%2FLeetCode-Challenge-log-617%2F</url>
    <content type="text"><![CDATA[617. Merge Two BInary Treeshttps://leetcode.com/problems/merge-two-binary-trees/description/ DFS Problem. Recursive Solution. Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: 1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 Note: The merging process must start from the root nodes of both trees. Soulution:123456789101112131415161718class Solution: def mergeTrees(self, t1, t2): """ :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode """ if t1 is None and t2 is None: return None elif t1 is None: return t2 elif t2 is None: return t1 else: t1.val += t2.val t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) return t1]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 657]]></title>
    <url>%2F2018%2F04%2F09%2FLeetCode-Challenge-log-657%2F</url>
    <content type="text"><![CDATA[657. Judge Route CircleSimple, no need to comment Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L(Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example 1: 12Input: &quot;UD&quot;Output: true Example 2: 12Input: &quot;LL&quot;Output: false Soulution:123456789101112131415161718class Solution: def judgeCircle(self, moves): """ :type moves: str :rtype: bool """ U = 0 R = 0 for i in moves: if i == 'U': U += 1 elif i == 'D': U -= 1 elif i == 'R': R += 1 else: R -= 1 return (U == 0 and R == 0)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 797]]></title>
    <url>%2F2018%2F04%2F09%2FLeetCode-Challenge-log-797%2F</url>
    <content type="text"><![CDATA[797. All Paths From Source to Target Basic DFS problem. Caching may accerlerate the time, but I did not try~ Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists. 123456789Example:Input: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:0---&gt;1| |v v2---&gt;3There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3. Note: The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path. Soulution:1234567891011121314151617class Solution: def allPathsSourceTarget(self, graph): """ :type graph: List[List[int]] :rtype: List[List[int]] """ allPaths = [] self.printPaths([0], graph, allPaths) return allPaths def printPaths(self, path, graph, allPaths): if len(graph[path[-1]]) != 0: for i in graph[path[-1]]: if i == len(graph) - 1: allPaths.append(path[:] + [i]) else: self.printPaths(path[:] + [i], graph, allPaths)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 461]]></title>
    <url>%2F2018%2F04%2F09%2FLeetCode-Challenge-log-461%2F</url>
    <content type="text"><![CDATA[461. Hamming Distancehttps://leetcode.com/problems/hamming-distance/description/ Use bitwise operation XOR (1 if the bit is different). Count the number of 1 bits ( exactly as NO.191). The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example: 12345678910Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. Soulution:12345678910111213class Solution(object): def hammingDistance(self, x, y): """ :type x: int :type y: int :rtype: int """ temp = x ^ y count = 0 while temp &gt; 0: temp = temp &amp; (temp-1) count += 1 return count or even shorter: 12345678class Solution(object): def hammingDistance(self, x, y): """ :type x: int :type y: int :rtype: int """ return bin(x ^ y).count('1')]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>bit operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 535]]></title>
    <url>%2F2018%2F04%2F07%2FLeetCode-Challenge-log-535%2F</url>
    <content type="text"><![CDATA[535. Encode and Decode TinyURLhttps://leetcode.com/problems/encode-and-decode-tinyurl/description/ Solution1: Use increasing numbers to mark tiny urls; actual urls are saved in a indexed list. (If want letters, can transfer the number into 62-based) Alternative: Genrate random 6-places string as tiny url. Two dictionaries to allow mapping in two ways and no duplicate. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Soulution:123456789101112131415161718192021222324252627### s1 ###class Codec: def __init__(self): self.urls = [] def encode(self, longUrl): """Encodes a URL to a shortened URL. :type longUrl: str :rtype: str """ self.urls.append(longUrl) return 'http://tinyurl.com/' + '&#123;:0&gt;6d&#125;'.format(len(self.urls)-1) def decode(self, shortUrl): """Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str """ index = int(shortUrl[-6:]) return self.urls[index]# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(url)) 123456789101112131415161718192021222324252627282930313233343536### s2 ###import randomclass Codec: alphabet = string.ascii_letters + '0123456789' def __init__(self): self.long = dict() self.tiny = dict() def encode(self, longUrl): """Encodes a URL to a shortened URL. :type longUrl: str :rtype: str """ if longUrl in self.long: return self.long[longUrl] while True: tiny = ''.join([random.choice(Codec.alphabet) for i in range(6)]) if tiny not in self.tiny: break self.long[longUrl] = tiny self.tiny[tiny] = longUrl return 'http://tinyurl.com/' + tiny def decode(self, shortUrl): """Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str """ tiny = shortUrl[-6:] return self.tiny[tiny]# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(url))]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 804]]></title>
    <url>%2F2018%2F04%2F07%2FLeetCode-Challenge-log-804%2F</url>
    <content type="text"><![CDATA[804. Unique Morse Code Wordshttps://leetcode.com/problems/unique-morse-code-words/description/ Use set to maintain unique words. String is hashable. International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: &quot;a&quot;maps to &quot;.-&quot;, &quot;b&quot; maps to &quot;-...&quot;, &quot;c&quot; maps to &quot;-.-.&quot;, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. Soulution:123456789101112class Solution: def uniqueMorseRepresentations(self, words): """ :type words: List[str] :rtype: int """ trans = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..",\ "--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] s = set() for word in words: s.add(''.join([trans[ord(letter) - ord('a')] for letter in word])) return len(s)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 771]]></title>
    <url>%2F2018%2F04%2F06%2FLeetCode-Challenge-log-771%2F</url>
    <content type="text"><![CDATA[771. Jewels and Stoneshttps://leetcode.com/problems/jewels-and-stones/description/ Use hashing to achieve O(n+m). Use set as a dict without value to save space You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in Sis a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Example 1: 12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 Example 2: 12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. Soulution:Both O(1) 12345678910111213141516# use dictclass Solution: def numJewelsInStones(self, J, S): """ :type J: str :type S: str :rtype: int """ isJew = &#123;&#125; result = 0 for i in J: isJew[i] = 1 for i in S: if i in isJew: result += 1 return result 123456789# use setclass Solution: def numJewelsInStones(self, J, S): """ :type J: str :type S: str :rtype: int """ return sum([1 for s in S if s in set(J)])]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>hash</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 215]]></title>
    <url>%2F2018%2F04%2F06%2FLeetCode-Challenge-log-215%2F</url>
    <content type="text"><![CDATA[215. Kth Largest Element in an Arrayhttps://leetcode.com/problems/kth-largest-element-in-an-array/description/ Use len(k)-array to save the largest k elements Through binary search insertion to keep the array sorted. Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. Credits:Special thanks to @mithmatt for adding this problem and creating all test cases. Soulution:123456789101112131415161718192021222324252627282930313233# binary search insertionclass Solution: def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) == 1: return nums[0] arr = [] for ele in nums: if len(arr) == k: if ele &lt; arr[k-1]: continue elif ele &gt;= arr[0]: arr = [ele] + arr[:-1] continue arr = self.insert(arr, ele) if len(arr) &gt; k: arr = arr[:k] return arr[k-1] def insert(self, arr, ele): if arr == []: return [ele] p1 = 0 p2 = len(arr)-1 while p2 &gt;= p1: temp = (p1 + p2) // 2 if ele &gt;= arr[temp]: p2 = temp - 1 else: p1 = temp + 1 # print(p1,p2,ele) return arr[:p1] + [ele] + arr[p1:] 1# use set]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>need reviewed</tag>
        <tag>binary search</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gundam] Metal Build F91]]></title>
    <url>%2F2018%2F04%2F06%2FGundam-Metal-Build-F91%2F</url>
    <content type="text"><![CDATA[A birthday gift from my important one. Gundam Formular 91 combines with the latest metal build techniques, filled with a sense of high bio tech.]]></content>
      <tags>
        <tag>gundam</tag>
        <tag>mb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 152]]></title>
    <url>%2F2018%2F04%2F05%2FLeetCode-Challenge-log-152%2F</url>
    <content type="text"><![CDATA[152. Maximum Product Subarrayhttps://leetcode.com/problems/maximum-product-subarray/description/ It is a DP problem. Similar to 53. Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. Solution:DP thought: use two slot to cache the max and the min products of the subarray that ends with current pointer. at each position, each time there are three possible numbers to choose from: current number current number X max product of last position current number X min product of last position so take the min and max of the three options to be current minP and maxP of current postion 12345678910111213141516171819class Solution: def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ maxP = nums[0] minP = nums[0] p = 1 result = nums[0] while p &lt; len(nums): tmp1 = max(nums[p], nums[p] * maxP, nums[p] * minP) tmp2 = min(nums[p], nums[p] * maxP, nums[p] * minP) maxP = tmp1 minP = tmp2 print(nums[p], maxP, minP) result = max(result, maxP) p += 1 return result]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>subarray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 53]]></title>
    <url>%2F2018%2F04%2F05%2FLeetCode-Challenge-log-53%2F</url>
    <content type="text"><![CDATA[53. Maximium Subarrayhttps://leetcode.com/problems/maximum-subarray/description/ It is mainly a DP problem. Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. Solution:DP thought: last represents the largest sum in the subarray that ends with current pointer. The key is last[p] = max(last[p-1], 0) + nums[p], meaning we only include last[p-1] if it is positive 12345678910111213class Solution: def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ result = last = nums[0] p = 1 while p&lt;len(nums): last = nums[p] + max(last, 0) result = max(result, last) p += 1 return result]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>subarray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 401]]></title>
    <url>%2F2018%2F04%2F05%2FLeetCode-Challenge-log-401%2F</url>
    <content type="text"><![CDATA[401. Binary Watchhttps://leetcode.com/problems/binary-watch/description/ A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: 12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. Solution:123456789101112131415161718192021222324252627282930313233343536# cache all (number of leds, mins/hours&#125; in dict# check all combination class Solution: def readBinaryWatch(self, num): """ :type num: int :rtype: List[str] """ hours = &#123;&#125; for i in range(12): numberOfLed = bin(i).count('1') if numberOfLed not in hours: hours[numberOfLed] = [str(i)] else: hours[numberOfLed].append(str(i)) print(hours) mins = &#123;&#125; for i in range(60): if i &gt;= 10: temp = str(i) else: temp = '0' + str(i) numberOfLed = bin(i).count('1') if numberOfLed not in mins: mins[numberOfLed] = [temp] else: mins[numberOfLed].append(temp) print(mins) results = [] for h in range(num+1): m = num - h if m in mins and h in hours: results = results + [ hh + ':' + mm for hh in hours[h] for mm in mins[m]] return results 123456789# same idea but 200% neaterclass Solution: def readBinaryWatch(self, num): """ :type num: int :rtype: List[str] """ return ["&#123;&#125;:&#123;:0&gt;2d&#125;".format(i,j) for i in range(12) for j in range(60) \ if bin(i).count('1') + bin(j).count('1') == num]]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python String Format]]></title>
    <url>%2F2018%2F04%2F05%2FPython-String-Format%2F</url>
    <content type="text"><![CDATA[Number FormattingThe following table shows various ways to format numbers using python’s str.format(), includes examples for both float formatting and integer formatting. To run examples use print(&quot;FORMAT&quot;.format(NUMBER));So to get the output of the first example, you would run: print(&quot;{:.2f}&quot;.format(3.1415926)); Number Format Output Description 3.1415926 {:.2f} 3.14 2 decimal places 3.1415926 {:+.2f} +3.14 2 decimal places with sign -1 {:+.2f} -1.00 2 decimal places with sign 2.71828 {:.0f} 3 No decimal places 5 {:0&gt;2d} 05 Pad number with zeros (left padding, width 2) 5 {:x&lt;4d} 5xxx Pad number with x’s (right padding, width 4) 10 {:x&lt;4d} 10xx Pad number with x’s (right padding, width 4) 1000000 {:,} 1,000,000 Number format with comma separator 0.25 {:.2%} 25.00% Format percentage 1000000000 {:.2e} 1.00e+09 Exponent notation 13 {:10d} 13 Right aligned (default, width 10) 13 {:&lt;10d} 13 Left aligned (width 10) 13 {:^10d} 13 Center aligned (width 10)]]></content>
      <tags>
        <tag>python</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SQL] [LeetCode] Challenge log 182]]></title>
    <url>%2F2018%2F04%2F04%2FLeetCode-Challenge-log-182%2F</url>
    <content type="text"><![CDATA[182. Duplicate Emailshttps://leetcode.com/problems/duplicate-emails/description/ Write a SQL query to find all duplicate emails in a table named Person. 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ For example, your query should return the following for the above table: 12345+---------+| Email |+---------+| a@b.com |+---------+ Note: All emails are in lowercase. Solution:1234Select EmailFrom Person Group by EmailHaving Count(*) &gt; 1]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 756]]></title>
    <url>%2F2018%2F04%2F04%2FLeetCode-Challenge-log-756%2F</url>
    <content type="text"><![CDATA[756. Pyramid Transition Matrixhttps://leetcode.com/problems/pyramid-transition-matrix/ We are stacking blocks to form a pyramid. Each block has a color which is a one letter string, like &#39;Z&#39;. For every block of color C we place not in the bottom row, we are placing it on top of a left block of color A and right block of color B. We are allowed to place the block there only if (A, B, C) is an allowed triple. We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3. Return true if we can build the pyramid all the way to the top, otherwise false. Example 1: 1234567891011Input: bottom = &quot;XYZ&quot;, allowed = [&quot;XYD&quot;, &quot;YZE&quot;, &quot;DEA&quot;, &quot;FFF&quot;]Output: trueExplanation:We can stack the pyramid like this: A / \ D E / \ / \X Y ZThis works because (&apos;X&apos;, &apos;Y&apos;, &apos;D&apos;), (&apos;Y&apos;, &apos;Z&apos;, &apos;E&apos;), and (&apos;D&apos;, &apos;E&apos;, &apos;A&apos;) are allowed triples. Example 2: 12345Input: bottom = &quot;XXYX&quot;, allowed = [&quot;XXX&quot;, &quot;XXY&quot;, &quot;XYX&quot;, &quot;XYY&quot;, &quot;YXZ&quot;]Output: falseExplanation:We can&apos;t stack the pyramid to the top.Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D. Note: bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;}. Solution: Build all possible bottoms for nect level and recur. 12345678910111213141516171819202122232425262728293031323334353637class Solution: def pyramidTransition(self, bottom, allowed): """ :type bottom: str :type allowed: List[str] :rtype: bool """ hashmap = &#123;&#125; for tp in allowed: if tp[:2] not in hashmap: hashmap[tp[:2]] = [tp[2]] else: hashmap[tp[:2]].append(tp[2]) print(hashmap) return self.pyramidOk(bottom, hashmap) def pyramidOk(self, bottom, hashmap): if len(bottom) == 1: return True bottomList = [] for i in range(len(bottom)-1): if bottom[i:i+2] not in hashmap: return False else: bottomList.append(hashmap[bottom[i:i+2]]) newBottom = [] self.makeBottom(bottomList, newBottom, '') for bt in newBottom: if self.pyramidOk(bt, hashmap): return True return False def makeBottom(self, bottomList, newBottom, curr): if len(bottomList) == 0: newBottom.append(curr) return curr for i in bottomList[0]: self.makeBottom(bottomList[1:], newBottom, curr + i) A slightly different version, use yield and iterator to save space 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def pyramidTransition(self, bottom, allowed): """ :type bottom: str :type allowed: List[str] :rtype: bool """ hashmap = &#123;&#125; for tp in allowed: if tp[:2] not in hashmap: hashmap[tp[:2]] = [tp[2]] else: hashmap[tp[:2]].append(tp[2]) return self.pyramidOk(bottom, hashmap) def pyramidOk(self, bottom, hashmap): if len(bottom) == 1: return True bottomList = [] for i in range(len(bottom)-1): if bottom[i:i+2] not in hashmap: return False else: bottomList.append(hashmap[bottom[i:i+2]]) for bt in self.makeBottom(bottomList, ''): if self.pyramidOk(bt, hashmap): return True return False def makeBottom(self, bottomList, curr): if len(bottomList) == 0: yield curr else: for i in bottomList[0]: for j in self.makeBottom(bottomList[1:], curr + i): yield j]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>yeild</tag>
        <tag>recursive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 398]]></title>
    <url>%2F2018%2F04%2F03%2FLeetCode-Challenge-log-398%2F</url>
    <content type="text"><![CDATA[398. Random Pick Indexhttps://leetcode.com/problems/random-pick-index/description/ Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note:The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: 12345678int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); Solution: space O(1), time O(n) use 1 slot to hold output. if the n^th index is found, it has 1/n probability to replace the slot. (can use mutiple slot and the answer will be same) 123456789101112131415161718192021222324252627282930import random as rdclass Solution: nums = [] def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def pick(self, target): """ :type target: int :rtype: int """ output = None count = 0 for i in range(len(self.nums)): if self.nums[i] == target: count += 1 if output is None or rd.randint(1,count) == 1: output = i if output is None: return None return output# Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.pick(target) 1234567891011121314151617181920212223242526272829303132333435# first try, use two slotsimport random as rdclass Solution: nums = [] def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def pick(self, target): """ :type target: int :rtype: int """ can = [] count = 0 for i in range(len(self.nums)): if self.nums[i] == target: count += 1 if len(can) &lt; 2: can.append(i) else: temp = rd.randint(1,count) if temp &lt;= 2: can[temp-1] = i if len(can) == 0: return None if len(can) == 1: return can[0] return can[rd.randint(0,1)]# Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.pick(target)]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 191]]></title>
    <url>%2F2018%2F04%2F03%2FLeetCode-Challenge-log-191%2F</url>
    <content type="text"><![CDATA[191. Number of 1 Bitshttps://leetcode.com/problems/number-of-1-bits/description/ Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. Solution:12345678910111213# normal solution O(log n) = O(32) = O(1), since n = 32 bitsclass Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 count = 1 while (n&gt;1): if n % 2 == 1: count += 1 n = n // 2 return count 123456789101112# bit operation trick O(1)class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n != 0: n = n &amp; n-1 count += 1 return count 12345678# built-in function (cheating)class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ return bin(n).count('1') Python bit operation:123456789101112131415161718192021a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0c = a &amp; b; # 12 = 0000 1100print "Line 1 - Value of c is ", cc = a | b; # 61 = 0011 1101 print "Line 2 - Value of c is ", cc = a ^ b; # 49 = 0011 0001print "Line 3 - Value of c is ", cc = ~a; # -61 = 1100 0011print "Line 4 - Value of c is ", cc = a &lt;&lt; 2; # 240 = 1111 0000print "Line 5 - Value of c is ", cc = a &gt;&gt; 2; # 15 = 0000 1111print "Line 6 - Value of c is ", c]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 9: Polymophism]]></title>
    <url>%2F2018%2F03%2F29%2FJava-Review-9%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 101]]></title>
    <url>%2F2018%2F03%2F29%2FLeetCode-Challenge-log-101%2F</url>
    <content type="text"><![CDATA[101. Symmetric Treehttps://leetcode.com/problems/symmetric-tree/description/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. Solution: iterative 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if root is None: return True q1 = [root] q2 = [root] pointer = 0 while (pointer &lt; len(q1)): l = q1[pointer] r = q2[pointer] # both none if (l is None and r is None): pointer += 1 continue # one none if (l is None or r is None): return False # equal if (l.val == r.val): q1 = q1 + [l.left, l.right] q2 = q2 + [r.right, r.left] pointer += 1 continue # not equal if (l.val != r.val): return False return True ​ recursive 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if root is None: return True return isMirror(root.left, root.right) def isMirror(l,r): if (l is None) and (r is None): return True if (l is None) or (r is None): return False if (l.val == r.val) and (isMirror(l.left, r.right)) and (isMirror(l.right, r.left)): return True return False ​]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 807]]></title>
    <url>%2F2018%2F03%2F29%2FLeetCode-Challenge-log-807%2F</url>
    <content type="text"><![CDATA[807. Max Increase to Keep City Skylinehttps://leetcode.com/problems/max-increase-to-keep-city-skyline/description/ In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? 12345678910111213141516171819Example:Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]Output: 35Explanation: The grid is:[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ]The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3]The grid after increasing the height of buildings without affecting skylines is:gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes: 1 &lt; grid.length = grid[0].length &lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism. Solution:123456789101112131415161718192021class Solution: def maxIncreaseKeepingSkyline(self, grid): """ :type grid: List[List[int]] :rtype: int """ n = len(grid) mrow = [0]*n mcol = [0]*n for i in range(n): for j in range(n): mrow[i] = max(mrow[i], grid[i][j]) mcol[j] = max(mcol[j], grid[i][j]) maxHeight = 0 for i in range(n): for j in range(n): tmp = min(mrow[i], mcol[j])-grid[i][j] maxHeight += tmp return maxHeight]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 8: Object class]]></title>
    <url>%2F2018%2F03%2F28%2FJava-Review-8%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Java API specfication: http://www.oracle.com/technetwork/java/api-141528.html I. Object Object is the root class of all classes. ex. 1public class &lt;classnanme&gt;&#123;&#125; is equal to 1public class &lt;classnanme&gt; extends Object&#123;&#125; toString(): when connector is used, this super method is auto-executed. return “\&lt;classname>@\&lt;hashcode>“. usually overriden. equals(): if using ==, it is actually comparing ref. address. default is same as == should be overriden, ex: 123456789101112public boolean equals(Object obj)&#123; if (obj == null) return false; else&#123; if (obj instanceof Cat)&#123; Cat c = (Cat) obj; if (c.color ==this color &amp;&amp; c.height == this.height)&#123; return true; &#125; &#125; &#125; return false;&#125; II. Casting A superclass ref. can point to its subclass instance. For above, it can not access new member variables in its subclass. instanceof can be used to check if an instance belongs to a class or superclass. upcasting: treat subclass as superclass; downcasting: treat superclass as subclass; 1234567891011121314151617181920212223//sample application public class Test&#123; public static void main(String args[])&#123; Test test = new Test(); Animal a = new Animal("name"); Cat c = new Cat("catname", "blue"); Dog d = new Dog("dogname", "black"); test.f(a); test.f(c); test.f(d); &#125; public void f(Animal a)&#123; System.out.println("name: " + a.name); if (a instanceof Cat)&#123; Cat cat = (Cat)a; System.out.println("eyecolor: " + cat.eyecolor); &#125; else if (a instanceof Dog) &#123; Dog dog = (Dog)a; System.out.println("furcolor: " + dog.furcolor); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 1]]></title>
    <url>%2F2018%2F03%2F28%2FLeetCode-Challenge-log-1%2F</url>
    <content type="text"><![CDATA[1. Two Sumhttps://leetcode.com/problems/two-sum/description/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 12345678910111213141516# Keywords: hash table, dictionaryclass Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ n = len(nums) ht = &#123;&#125; for i in range(n): temp = target - nums[i] if ht.__contains__(temp) and ht[temp] != i: return [ht[temp], i] ht[nums[i]] = i return None]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>two sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 7: Access control]]></title>
    <url>%2F2018%2F03%2F27%2FJava-Review-7%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 I. Access control keywords keyword within class within package son class anywhere private ✅ default ✅ ✅ protected ✅ ✅ ✅ public ✅ ✅ ✅ ✅ For class, only public and default are used. default members can be accessed by a class that belongs to the same package. II. Use extends to inherit A son class inherits all members of its superclass (varibales and methods). Java only allows single inheritage. A son can have only one father(superclass). 1&lt;modifier&gt; class &lt;name&gt; [extends &lt;superclass&gt;]&#123;...&#125; III. Overwite (override) A method of a son class can override the original method in its superclass. To realize, the followings needs to be satisfied: same name. same return type. same parameters list. can not use stricter access control. ​ IV. Super In a son class, use super.&lt;name&gt; to refer superclass members. V. Constructive method in inheritage Son constructive method must first use superclass constructive method. If no super used, the son’s constructive method first executes the superclass’s non-parametrized constructive method, namely super(); If there exists no super(), compile error. The alternate is to use super(p1,p2) in the first line to call specific superclass’s constructive method.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 6: Package & import]]></title>
    <url>%2F2018%2F03%2F22%2FJava-Review-6%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 package &amp; import are used to resolve repeated class names. package Declare what package the class(es) belongs to. Declared at 1st line in java: 1package pk1.pk2.pk3; If none package line —&gt; nameless package . Java manages packages by directory. For instance, the above .java will located at ./pk1/pk2/pk3. import12345678//specific classimport pk1.pk2.pk3.classname;// all classes of a packageimport pk1.pk2.pk3.*; //without importpk1.pk2.pk3.classname abc = new pk1.pk2.pk3.classname() JDK main packages java.lang: String, Math, Integer, System, Thread (default import) java.awt: abstract window toolkits java.applet java.net jave.io java.util 1jar -cvf xx.jar *.*]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gundam] MG ZZ (processing)]]></title>
    <url>%2F2018%2F03%2F21%2FGundam-MG-ZZ-processing%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Gundam</tag>
        <tag>MG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 5: this and static]]></title>
    <url>%2F2018%2F03%2F16%2FJava-Review-5%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Keyword this In a method of a class , this refers to the object that uses the method. Sometime it can be used to deal with the case that member varibales and method parameters have same names. (ref. uses the closest def.) this can be view as a variable, whose value is the reference of the current object. Keyword static In a class, a static member variable is defined to be a shared variable for the class. When the class is first used, thestatic variable is initialized. For all the instance of the class, there is only one copy of this varible. When a method is defined as static, this method, as it is called, will not parsed the ref. of the instance to the method, and hence will not able to use non-static variables. We can use either instance ref. or class name (without a instance) to access static members. 12345678910111213141516171819202122// ex: use static var as counterpublic class Cat&#123; private static int sid = 0; private String name; int id; Cat(String name)&#123; this.name = name; id = sid++; &#125; public void info()&#123; System.out.println ("My name is" + name + "No." + id); &#125; public static void main(String arg[])&#123; Cat.sid = 100; Cat mimi = new Cat("mimi"); Cat pipi = new Cat("pipi"); mimi.info(); pipi.info(); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 4: Ram analysis]]></title>
    <url>%2F2018%2F03%2F16%2FJava-Review-4%2F</url>
    <content type="text"><![CDATA[The following notes are based on video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Step by step ram analysis Corresponding Code: 1234567891011121314151617181920212223242526272829303132333435363738public class Point &#123; double x; double y; double z; Point(double _x, double _y, double _z)&#123; x = _x; y = _y; z = _z; &#125; public void setX(double _x)&#123; x = _x; &#125; public void setY(double _y)&#123; y = _y; &#125; public void setZ(double _z)&#123; z = _z; &#125; public double getDistance(Point p)&#123; return Math.pow(x-p.x,2) + Math.pow(y-p.y,2) + Math.pow(y-p.y,2); &#125;&#125;class TestPoint&#123; public static void main(String[] args) &#123; double a = 1.0, b = 2.0, c = 3.0; Point p1 = new Point(a, b, c); p1.setX(4); System.out.println(p1.getDistance(new Point(3,2,1))); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Parameters Parsing]]></title>
    <url>%2F2018%2F03%2F16%2FNotes-Parameters-Parsing%2F</url>
    <content type="text"><![CDATA[Diffrent languages has diffrent features about parsing parameters. There exists a lot of cofusion around this topic, especailly as people tends to use words like “parsing reference” and “parsing values” trying simplify the problem. Unfortunately, it only leads to more confusion. We need to understand the lower layer. Java All are parsed by values. Eight primitive data types (char, byte, short, int, long, float, double, boolean) are saved in stack. When called, the value of the data is parsed. Refrence data types (object, array) are saved in heap, referred by a address saved in stack. When called, the address value is parsed. Special notice: a String, although being a object, can be viewed as same as ptimitive data type. Because the content in a String is immutable. Python Mutable data type: list, dict and others are parsed by reference. Immutable data type: number, string and tuple type are parsed by value. … to be continued]]></content>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 3: Object oriented programming]]></title>
    <url>%2F2018%2F03%2F15%2FJava-Review-3%2F</url>
    <content type="text"><![CDATA[The following notes are based on the book: &lt;&lt; Head First JAVA &gt;&gt; and video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 Process - oriented programming divde into processes process by process Object - oriented programming divide into objects(tools) realized by methods within a object everthing in java is a object Resuseable, Extensibility, easy to maintain and replace Object and class A object is an instance of a class. A class is a template. A object has attribute (member variable) and method. Relationships between classes (more later) Inheritance Association Composition Aggregation Realization Define a class Member variables can have a default. otherwise java automatically init them (0, ‘0’, null). 123456789public class Person()&#123; // member varibles int id; int age = 20; public void sayHello()&#123; System.out.print('hello!'); &#125;&#125; Construction method same name as class no return, no void 123456789public class Person&#123; int id; int age = 20; Person(int _id, int _age)&#123; id = _id; age = _age; &#125;&#125; Default construction method if no construction method is specified, default is used: 1Person()&#123;&#125; otherwise, default is overridden. Overload construction method Mutiple construction methods are allowed. Method names have to be same (same as class name). Can be distinguished by either: number of parameters paremeters’ types 12345678// init person with specific id and agePerson(int _id, int _age)&#123; id = _id; age = _age;&#125;// init person with specific id and default age (set to 20 mannually)Person(int _id)&#123; id = _id; age = 20;&#125;// init person with default age and default idPerson()&#123;id = _id; age = _age;&#125; Overload normal method same as above Method return type also need to be same. Reference type takes two space in ram. (address and instance) address is saved in stack ram. new instance is saved in heap ram. method does not use space until called! 12String s; // create a reference type, iss = new String('hello world'); // create a instance, assigned to s Rule of naming Class names begin with upper case. Variable names and method names begin with lower case. Use camelSignal if a name contains mutiple words.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 2: Java syntax and more]]></title>
    <url>%2F2018%2F03%2F15%2FJava-Review-2%2F</url>
    <content type="text"><![CDATA[The following notes are based on the book: &lt;&lt; Head First JAVA &gt;&gt; and video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 - For loopThe process follows: execute ep1 if ep2 is true, go to 3; otherwise break; execute statements execute ep3 iterate again 2~4 1234for (ep1; ep2; ep3)&#123; statement1; statement2; &#125; - While loop1234while(ep)&#123; statement1; statement2;&#125; - Do while loop12345//noteic the ';' after while!!!do &#123; st1; st2;&#125; while (ep); - If else12345if (ep1)&#123;&#125;if (ep1)&#123;&#125; else&#123;&#125;if (ep1)&#123;&#125; else if (ep2)&#123;&#125; else&#123;&#125; - Switch i must be int (char, short). if i = 8 , st1 is executed. case can dig through if breaknot existed. ex. if i = 10, st3 and st4 are executed. default is used to handle no-match. 123456789101112131415//exampleint i = 8;switch (i) &#123; case 8: st1; break; case 10: case 11: st3; case 12: st4; break; default: st5;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Unicode]]></title>
    <url>%2F2018%2F03%2F14%2FNotes-Unicode%2F</url>
    <content type="text"><![CDATA[Excerpt from https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html: 所以我们也可以这样理解,Unicode是用0至65535之间的数字来表示所有字符.其中0至127这128个数字表示的字符仍然跟ASCII完全一样.65536是2的16次方.这是第一步.第二步就是怎么把0至65535这些数字转化成01串保存到计算机中.这肯定就有不同的保存方式了.于是出现了UTF(unicode transformation format),有UTF-8,UTF-16. There are many problems can be caused by encoding. So it is a must to know how different languages handles encoding issues: Javajava uses unicode = utf-16 internally, but it seems neccessary to set it up on the surface. 1234567891011121314// set and print encodeing typeSystem.setProperty("file.encoding", "UTF-16");String a = System.getProperty("file.encoding");//conversion try &#123; // Convert from Unicode to UTF-8 String string = "abc\u5639\u563b"; byte[] utf8 = string.getBytes("UTF-8"); // Convert from UTF-8 to Unicode string = new String(utf8, "UTF-8");&#125; catch (UnsupportedEncodingException e) &#123;&#125; Python In Python 3, all strings are sequences of Unicode characters. There is a bytes type that holds raw bytes. In Python 2, a string may be of type str or of type unicode. You can tell which using code something like this: isinstance(s,str/unicode) 1234567891011# check encodeing type import syssys.getdefaultencoding()# set encoding type ("utf-8", "utf-16")#coding=utf-8# conversion ("utf-8", "utf-16", "unicode-escape" )s = '你好'ec = s.encode("utf-8")dc = ec.decode("utf-8")]]></content>
      <tags>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java Review] 1: The World of Java]]></title>
    <url>%2F2018%2F03%2F12%2FJava-Review-1%2F</url>
    <content type="text"><![CDATA[The following notes are based on the book: &lt;&lt; Head First JAVA &gt;&gt; and video series: 手把手教你用Java基础教程 - 北京尚学堂 - 马士兵 - Java is a interpreted languageAfter .java is compiled into .class, JVM takes .class as input, one line at a time, translates a line into machine language to have it executed. (The other kind is complied language, ex. C/C++) - Garbage CollectionJava has its own garbage collector to automatically clean up the unused ram. (C/C++ needs coder to manunlly specify the clean-up process) - Java’s work flow: JVM - Ram segement heap: new. stack: local data. data segment: static data, const data. code segment: code. - TerminologyJDK: java development kit (developer) JRE: java runtime environment (user) - Run java in shell12$ javac HelloWorld.class //compile$ java HelloWolrd //execute - Rules one .java can have at most only one public class public class, if exists, name has to be same as filename execution entry is fixed public static void main (String[] args) 12345public class MyFirstApp&#123; public static void main (String[] args)&#123; system.out.print("I Rule!"); //statement &#125; //method&#125; //class - Commement123456789101112// single line comment/* mutiple lines comments*//** * mnutiple lines * can be interpreted by dos */ - Java keywords abstract continue for new switch assert*** default goto* package synchronized boolean do if private this break double implements protected throw byte else import public throws case enum** instanceof return transient catch extends int short try char final interface static void class finally long strictfp** volatile const* float native super while - Java Variables 12345int i = 10; // default inteiger long l1 = 8888888L; // 'L' is a must!float f = 12.3f; // 'f' is a mustdouble d1, d2, d3 = 0.123; // only d3 is given 0.123;String s = 'hello'; Smaller types of variables can be cast to larger types: byte, short, char -&gt; int -&gt; long -&gt; float -&gt; double 12345678910111213141516171819202122232425public class TestConvert &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int i1 = 123; int i2 = 456; double d1 = (i1+i2) * 1.2; // (i1+i2) -&gt;double float f1 = (float) ((i1+i2) * 1.2); // force casting byte b1 = 1; byte b2 = 2; byte b3 = (byte) (b1+b2); // auto casting to int first, must force cast back double d2 = 1e200; float f2 = (float) d2; // overflow System.out.println(f2); // become inf float f3 = 1.23f; long l1 = 123; //auto cast to int long l2 = 300000L; float f = l1 + l2 + f3; // auto cast to float first System.out.println(f); long l = (long) f; // forced to get rid of after=decimal System.out.println(l); &#125;&#125; - Java operators123456789101112131415/* binary oprators + - ! &amp; -------- and | -------- or ^ -------- 异或， 同false异true &amp;&amp; || ---- 短路与，短路或： 若左表达式能确定整体取值，则不计算右表达式*/// triple expressionint score = 80;String type = score &lt; 60 ? "fail!": "pass!"; // string +int c = 100;System.out.println('c = ' + c); // c will be auto cast to string - Others java uses unicode (UTF-16), 1 character always takses 2 bytes.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photo Test]]></title>
    <url>%2F2018%2F03%2F12%2FPhoto-Test%2F</url>
    <content type="text"><![CDATA[Photo link Test:]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Mongodb]]></title>
    <url>%2F2018%2F03%2F09%2Fmogodb-note%2F</url>
    <content type="text"><![CDATA[Below are some self-collected commonly-used commands. start12345678910# run in the backgroundmongod# open interactive shellmongo# in python from pymongo import MongoClientClient = MongoClient()db = Client[dbname] database12345678# basicshow dbsshow tables/collectiondb use db_name# delete current databasedb.dropDatabase() collection123456789# create collection db.createCollection("col_name")# create fixed collection with space 6142800 KB, documents &lt; 10000db.createCollection("col_name", &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; )# delete collectiondb.collection.drop() documents12345678910111213141516171819202122232425262728293031323334# insert documents (collection auto created if not exiested)db.collection.insertOne(&#123;"a": 3&#125;)db.collection.insert(&#123;"name":"MarcoCai"&#125;)# insert document indirectlydocument = &#123;...&#125;db.collection.insert(document)# inset multiple db.collection.insertMany([&#123;"b": 3&#125;, &#123;'c': 4&#125;])# find documents under a collectiondb.collection.find()db.collection.find().pretty()db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()db.col.find( &#123;$or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty()db.col.find(&#123;"likes": &#123;$gt:50&#125;, $or: [&#123;"by": "菜鸟教程"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;).pretty()# high level finddb.col.find(&#123;"title" : &#123;$type : 2&#125;&#125;)db.collection.find(query, &#123;title: 1, by: 1&#125;) // inclusion模式 指定返回的键，不返回其他键db.collection.find(query, &#123;title: 0, by: 0&#125;) // exclusion模式 指定不返回的键,返回其他键# update documentdb.test_collection.updateOne(&#123;"name":"abc"&#125;,&#123;$set:&#123;"age":"28"&#125;&#125;)db.test_collection.updateMany(&#123;"age":&#123;$gt:"10"&#125;&#125;,&#123;$set:&#123;"status":"xyz"&#125;&#125;)# replace documentdb.collection.save( &lt;document&gt; )# delete documentdb.inventory.deleteMany(&#123;&#125;)db.inventory.deleteMany(&#123; status : "A" &#125;)db.inventory.deleteOne( &#123; status: "D" &#125; ) symbol123456$gt -------- greater than &gt;$gte --------- gt equal &gt;=$lt -------- less than &lt;$lte --------- lt equal &lt;=$ne ----------- not equal !=$eq -------- equal = ObjectidMongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象。 由于 ObjectId 中保存了创建的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 getTimestamp 函数来获取文档的创建时间: 12var newObject = ObjectId()newObject.getTimestamp() data type 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。]]></content>
      <tags>
        <tag>database</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Database]]></title>
    <url>%2F2018%2F03%2F09%2FDatabase-knowledges%2F</url>
    <content type="text"><![CDATA[Useful links: nosql intro：http://www.runoob.com/mongodb/nosql.html Different kinds of databases summaries:https://www.jianshu.com/p/107c6b045245 pymongo:https://zhuanlan.zhihu.com/p/20500518 从MySQL和MongoDB的对比，看SQL与NoSQL的较量– 运维派:http://www.yunweipai.com/archives/23797.html SQL与mongoDB对比及映射:http://blog.csdn.net/leshami/article/details/52692912]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Notes] Mac Command Line]]></title>
    <url>%2F2018%2F03%2F08%2FMac-command-line%2F</url>
    <content type="text"><![CDATA[Marking down some commonly used shell command: Mac 命令行命令history 显示命令历史列表[Tab] =命令行自动补全↑(Ctrl+p) 显示上一条命令↓(Ctrl+n) 显示下一条命令clear 清除 shell 提示屏幕exit 注销history 显示命令历史reset 刷新 shell 提示屏幕 Mac 命令行编辑快捷键↑(Ctrl+p) 显示上一条命令↓(Ctrl+n) 显示下一条命令!num 执行命令历史列表的第num条命令!! 执行上一条命令!?string? 执行含有string字符串的最新命令Ctrl+r 然后输入若干字符，开始向上搜索包含该字符的命令，继续按Ctrl+r，搜索上一条匹配的命令Ctrl+s 与Ctrl+r类似,只是正向检索Ctrl+f 光标向前移动一个字符,相当与-&gt;Ctrl+b 光标向后移动一个字符,相当与&lt;-opt+&lt;- 光标向前移动一个单词opt+-&gt; 光标向后移动一个单词ls !$ 执行命令ls，并以上一条命令的参数为其参数Ctrl+a 移动到当前行的开头Ctrl+e 移动到当前行的结尾Esc+b 移动到当前单词的开头Esc+f 移动到当前单词的结尾Ctrl+l 清屏Ctrl+u 剪切命令行中光标所在处之前的所有字符（不包括自身）Ctrl+k 剪切命令行中光标所在处之后的所有字符（包括自身）Ctrl+d 删除光标所在处字符Ctrl+h 删除光标所在处前一个字符Ctrl+y 粘贴刚才所删除的字符Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符）Ctrl+t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符Ctrl+v 插入特殊字符,如Ctrl+v+Tab加入Tab字符键Esc+t 颠倒光标所在处及其相邻单词的位置Ctrl+c 删除整行Ctrl+(x u) 按住Ctrl的同时再先后按x和u，撤销刚才的操作Ctrl+s 挂起当前shellCtrl+q 重新启用挂起的shell 下面的应用可能稍稍高级一点点!! - 上一条命令!-n - 倒数第N条历史命令!-n:p - 打印上一条命令（不执行）!?string？- 最新一条含有“string”的命令!-n:gs/str1/str2/ - 将倒数第N条命令的str1替换为str2，并执行（若不加g,则仅替换第一个）]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log 561]]></title>
    <url>%2F2008%2F04%2F12%2FLeetCode-Challenge-log-561%2F</url>
    <content type="text"><![CDATA[561. Array Partition I quick sort O(2nlog2n) &lt;= O(20000* (log2+ 100)) ordered array trick O(n + max - min) = O(2n + 20000) &lt;= 40000 Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 1234Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. Soulution:123456789101112131415161718192021# s1class Solution: def arrayPairSum(self, nums): """ :type nums: List[int] :rtype: int """ self.partition(nums, 0, len(nums)-1) return sum([nums[i] for i in range(0, len(nums), 2)]) def partition(self, nums, l, r): if l &gt;= r: return pivot = nums[r] low = l for i in range(l,r): if nums[i] &lt; pivot: nums[i], nums[low] = nums[low], nums[i] low += 1 nums[r], nums[low] = nums[low], nums[r] self.partition(nums, l, low-1) self.partition(nums, low + 1, r) 12345678# one liner s1class Solution: def arrayPairSum(self, nums): """ :type nums: List[int] :rtype: int """ return sum(sorted(nums)[::2]) 123456789101112131415161718#s2class Solution: def arrayPairSum(self, nums): """ :type nums: List[int] :rtype: int """ arr = [0] * 20001 res = 0 odd = True for num in nums: arr[num + 10000] += 1 for i in range(len(arr)): while arr[i] &gt; 0: if odd: res += i - 10000 odd = not odd arr[i] -= 1 return res]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>sorting</tag>
        <tag>quick sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Challenge log]]></title>
    <url>%2F2008%2F04%2F09%2FLeetCode-Challenge-log-template%2F</url>
    <content type="text"><![CDATA[. Soulution:12]]></content>
      <tags>
        <tag>code challenge</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
